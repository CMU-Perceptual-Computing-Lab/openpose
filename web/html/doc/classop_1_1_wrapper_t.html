<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenPose: op::WrapperT&lt; TDatum, TDatums, TDatumsSP, TWorker &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_doxygen_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenPose
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
   <div id="projectbrief">The first real-time multi-person system to jointly detect human body, hand, facial, and foot keypoints</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classop_1_1_wrapper_t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classop_1_1_wrapper_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">op::WrapperT&lt; TDatum, TDatums, TDatumsSP, TWorker &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a94151754dddc2a37044aea26b9dac6c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a94151754dddc2a37044aea26b9dac6c7">WrapperT</a> (const <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36">ThreadManagerMode</a> threadManagerMode=<a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a>)</td></tr>
<tr class="separator:a94151754dddc2a37044aea26b9dac6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e310384f3b898c4c3621e0e1ee6883"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a65e310384f3b898c4c3621e0e1ee6883">~WrapperT</a> ()</td></tr>
<tr class="separator:a65e310384f3b898c4c3621e0e1ee6883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba81304df06fbec71103973ce0041c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a6ba81304df06fbec71103973ce0041c5">disableMultiThreading</a> ()</td></tr>
<tr class="separator:a6ba81304df06fbec71103973ce0041c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b502ef38ee46749733ae3dda7e5fd31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a0b502ef38ee46749733ae3dda7e5fd31">setWorker</a> (const <a class="el" href="namespaceop.html#a970a2a768a2ace81605b1558c9fdec18">WorkerType</a> workerType, const TWorker &amp;worker, const bool workerOnNewThread=true)</td></tr>
<tr class="separator:a0b502ef38ee46749733ae3dda7e5fd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7508886116ccfbbb8567a1921591751e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a7508886116ccfbbb8567a1921591751e">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;wrapperStructPose)</td></tr>
<tr class="separator:a7508886116ccfbbb8567a1921591751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce073fb177c316aaeab406c1f4808db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a3ce073fb177c316aaeab406c1f4808db">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a> &amp;wrapperStructFace)</td></tr>
<tr class="separator:a3ce073fb177c316aaeab406c1f4808db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa18264f99da260efb8fa12dd293ee75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#aaa18264f99da260efb8fa12dd293ee75">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a> &amp;wrapperStructHand)</td></tr>
<tr class="separator:aaa18264f99da260efb8fa12dd293ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d83f0332c27aa64cde22c66755deec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#ad9d83f0332c27aa64cde22c66755deec">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_extra.html">WrapperStructExtra</a> &amp;wrapperStructExtra)</td></tr>
<tr class="separator:ad9d83f0332c27aa64cde22c66755deec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d5d56e63b8c6faee0d7954db95c69d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#af3d5d56e63b8c6faee0d7954db95c69d">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;wrapperStructInput)</td></tr>
<tr class="separator:af3d5d56e63b8c6faee0d7954db95c69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a7310bc4062fb72f5d26e37d6d7c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a98a7310bc4062fb72f5d26e37d6d7c70">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;wrapperStructOutput)</td></tr>
<tr class="separator:a98a7310bc4062fb72f5d26e37d6d7c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a37b4a945171fd42d1ab16b0b7e8205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a7a37b4a945171fd42d1ab16b0b7e8205">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_gui.html">WrapperStructGui</a> &amp;wrapperStructGui)</td></tr>
<tr class="separator:a7a37b4a945171fd42d1ab16b0b7e8205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478b8bd7deb43322f220593552fe683d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a478b8bd7deb43322f220593552fe683d">exec</a> ()</td></tr>
<tr class="separator:a478b8bd7deb43322f220593552fe683d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8111d8cdb984e996410ace159a896992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a8111d8cdb984e996410ace159a896992">start</a> ()</td></tr>
<tr class="separator:a8111d8cdb984e996410ace159a896992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061ea09aac902a8a44438feffd18998f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a061ea09aac902a8a44438feffd18998f">stop</a> ()</td></tr>
<tr class="separator:a061ea09aac902a8a44438feffd18998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0577721c5e714861b27ad4ff356980bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a0577721c5e714861b27ad4ff356980bc">isRunning</a> () const</td></tr>
<tr class="separator:a0577721c5e714861b27ad4ff356980bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89055f5cf4e762071479f5fec8d2faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#aa89055f5cf4e762071479f5fec8d2faf">setDefaultMaxSizeQueues</a> (const long long defaultMaxSizeQueues=-1)</td></tr>
<tr class="separator:aa89055f5cf4e762071479f5fec8d2faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fa1a518495e1e3684f05943d1c04f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a79fa1a518495e1e3684f05943d1c04f8">tryEmplace</a> (TDatumsSP &amp;tDatums)</td></tr>
<tr class="separator:a79fa1a518495e1e3684f05943d1c04f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442ff1e4fec93ec28457f7c7c4b4bfbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a442ff1e4fec93ec28457f7c7c4b4bfbb">waitAndEmplace</a> (TDatumsSP &amp;tDatums)</td></tr>
<tr class="separator:a442ff1e4fec93ec28457f7c7c4b4bfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c6cf519701c320ae53c597ae54a7aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#ae2c6cf519701c320ae53c597ae54a7aa">waitAndEmplace</a> (<a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;matrix)</td></tr>
<tr class="separator:ae2c6cf519701c320ae53c597ae54a7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9396d4490b90f32a45d4a80d2cd5c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a4d9396d4490b90f32a45d4a80d2cd5c7">tryPush</a> (const TDatumsSP &amp;tDatums)</td></tr>
<tr class="separator:a4d9396d4490b90f32a45d4a80d2cd5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0aea3f8bf81458c0662c46f4d345d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a0e0aea3f8bf81458c0662c46f4d345d5">waitAndPush</a> (const TDatumsSP &amp;tDatums)</td></tr>
<tr class="separator:a0e0aea3f8bf81458c0662c46f4d345d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb907a2718260a14c0472279254df84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#abcb907a2718260a14c0472279254df84">waitAndPush</a> (const <a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;matrix)</td></tr>
<tr class="separator:abcb907a2718260a14c0472279254df84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55af0ab1f0ea4329f2c0bb3feb92b835"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a55af0ab1f0ea4329f2c0bb3feb92b835">tryPop</a> (TDatumsSP &amp;tDatums)</td></tr>
<tr class="separator:a55af0ab1f0ea4329f2c0bb3feb92b835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3b605e0787b55ffd00725c09a1cd53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a3c3b605e0787b55ffd00725c09a1cd53">waitAndPop</a> (TDatumsSP &amp;tDatums)</td></tr>
<tr class="separator:a3c3b605e0787b55ffd00725c09a1cd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3818c026e33cc573ba8b5722daa003a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#a3818c026e33cc573ba8b5722daa003a7">emplaceAndPop</a> (TDatumsSP &amp;tDatums)</td></tr>
<tr class="separator:a3818c026e33cc573ba8b5722daa003a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca8a5dc6f342470c8241fda5cd6cdb9"><td class="memItemLeft" align="right" valign="top">TDatumsSP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper_t.html#aaca8a5dc6f342470c8241fda5cd6cdb9">emplaceAndPop</a> (const <a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;matrix)</td></tr>
<tr class="separator:aaca8a5dc6f342470c8241fda5cd6cdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TDatum = BASE_DATUM, typename TDatums = std::vector&lt;std::shared_ptr&lt;TDatum&gt;&gt;, typename TDatumsSP = std::shared_ptr&lt;TDatums&gt;, typename TWorker = std::shared_ptr&lt;Worker&lt;TDatumsSP&gt;&gt;&gt;<br />
class op::WrapperT&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;</h3>

<p><a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a>: OpenPose all-in-one wrapper template class. Simplified into Wrapper for <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a>&lt;std::vector&lt;Datum&gt;&gt; <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> allows the user to set up the input (video, webcam, custom input, etc.), pose, face and/or hands estimation and rendering, and output (integrated small GUI, custom output, etc.).</p>
<p>This function can be used in 2 ways:</p><ul>
<li>Synchronous mode: call the full constructor with your desired input and output workers.</li>
<li>Asynchronous mode: call the empty constructor <a class="el" href="classop_1_1_wrapper_t.html#a94151754dddc2a37044aea26b9dac6c7">WrapperT()</a> + use the emplace and pop functions to push the original frames and retrieve the processed ones.</li>
<li>Mix of them:<ul>
<li>Synchronous input + asynchronous output: call the constructor <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a>(<a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a>, workersInput, {}, true)</li>
<li>Asynchronous input + synchronous output: call the constructor WrapperT(ThreadManagerMode::Synchronous, nullptr, workersOutput, irrelevantBoolean, true) </li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00036">36</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a94151754dddc2a37044aea26b9dac6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94151754dddc2a37044aea26b9dac6c7">&#9670;&nbsp;</a></span>WrapperT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::<a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36">ThreadManagerMode</a>&#160;</td>
          <td class="paramname"><em>threadManagerMode</em> = <code><a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadManagerMode</td><td><a class="el" href="classop_1_1_thread.html">Thread</a> synchronization mode. If set to <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a>, everything will run inside the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a>. If <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a>(In/Out), then input (frames producer) and/or output (GUI, writing results, etc.) will be controlled outside the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> class by the user. See ThreadManagerMode for a detailed explanation of when to use each one. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00261">261</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a65e310384f3b898c4c3621e0e1ee6883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e310384f3b898c4c3621e0e1ee6883">&#9670;&nbsp;</a></span>~WrapperT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::~<a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. It automatically frees resources. </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00269">269</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9d83f0332c27aa64cde22c66755deec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d83f0332c27aa64cde22c66755deec">&#9670;&nbsp;</a></span>configure() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_extra.html">WrapperStructExtra</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructExtra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogous to <a class="el" href="classop_1_1_wrapper_t.html#a7508886116ccfbbb8567a1921591751e">configure()</a> but applied to the extra options (<a class="el" href="structop_1_1_wrapper_struct_extra.html">WrapperStructExtra</a>) </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00359">359</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a3ce073fb177c316aaeab406c1f4808db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce073fb177c316aaeab406c1f4808db">&#9670;&nbsp;</a></span>configure() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructFace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogous to configure(WrapperStructPose) but applied to face (<a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a>) </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00333">333</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a7a37b4a945171fd42d1ab16b0b7e8205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a37b4a945171fd42d1ab16b0b7e8205">&#9670;&nbsp;</a></span>configure() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_gui.html">WrapperStructGui</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructGui</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogous to <a class="el" href="classop_1_1_wrapper_t.html#a7508886116ccfbbb8567a1921591751e">configure()</a> but applied to the GUI (<a class="el" href="structop_1_1_wrapper_struct_gui.html">WrapperStructGui</a>) </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00398">398</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="aaa18264f99da260efb8fa12dd293ee75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa18264f99da260efb8fa12dd293ee75">&#9670;&nbsp;</a></span>configure() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructHand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogous to <a class="el" href="classop_1_1_wrapper_t.html#a7508886116ccfbbb8567a1921591751e">configure()</a> but applied to hand (<a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a>) </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00346">346</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="af3d5d56e63b8c6faee0d7954db95c69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d5d56e63b8c6faee0d7954db95c69d">&#9670;&nbsp;</a></span>configure() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogous to <a class="el" href="classop_1_1_wrapper_t.html#a7508886116ccfbbb8567a1921591751e">configure()</a> but applied to the input (<a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a>) </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00372">372</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a98a7310bc4062fb72f5d26e37d6d7c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a7310bc4062fb72f5d26e37d6d7c70">&#9670;&nbsp;</a></span>configure() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructOutput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogous to <a class="el" href="classop_1_1_wrapper_t.html#a7508886116ccfbbb8567a1921591751e">configure()</a> but applied to the output (<a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>) </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00385">385</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a7508886116ccfbbb8567a1921591751e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7508886116ccfbbb8567a1921591751e">&#9670;&nbsp;</a></span>configure() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructPose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It configures the pose parameters. Do not call for default values. </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00320">320</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a6ba81304df06fbec71103973ce0041c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba81304df06fbec71103973ce0041c5">&#9670;&nbsp;</a></span>disableMultiThreading()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::disableMultiThreading</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable multi-threading. Useful for debugging and logging, all the Workers will run in the same thread. Note that workerOnNewThread (argument for setWorker function) will not make any effect. </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00287">287</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="aaca8a5dc6f342470c8241fda5cd6cdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca8a5dc6f342470c8241fda5cd6cdb9">&#9670;&nbsp;</a></span>emplaceAndPop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TDatumsSP <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::emplaceAndPop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classop_1_1_wrapper_t.html#a3818c026e33cc573ba8b5722daa003a7">emplaceAndPop(TDatumsSP&amp; tDatums)</a>, but it takes a <a class="el" href="classop_1_1_matrix.html">Matrix</a> as input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td><a class="el" href="classop_1_1_matrix.html">Matrix</a> with the image to be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TDatumsSP element where the processed information will be placed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00690">690</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a3818c026e33cc573ba8b5722daa003a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3818c026e33cc573ba8b5722daa003a7">&#9670;&nbsp;</a></span>emplaceAndPop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::emplaceAndPop </td>
          <td>(</td>
          <td class="paramtype">TDatumsSP &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs both waitAndEmplace and waitAndPop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>TDatumsSP element where the retrieved element will be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be retrieved. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00673">673</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a478b8bd7deb43322f220593552fe683d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478b8bd7deb43322f220593552fe683d">&#9670;&nbsp;</a></span>exec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::exec</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to start multi-threading. Similar to <a class="el" href="classop_1_1_wrapper_t.html#a8111d8cdb984e996410ace159a896992">start()</a>, but <a class="el" href="classop_1_1_wrapper_t.html#a478b8bd7deb43322f220593552fe683d">exec()</a> blocks the thread that calls the function (it saves 1 thread). Use <a class="el" href="classop_1_1_wrapper_t.html#a478b8bd7deb43322f220593552fe683d">exec()</a> instead of <a class="el" href="classop_1_1_wrapper_t.html#a8111d8cdb984e996410ace159a896992">start()</a> if the calling thread will otherwise be waiting for the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> to end. </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00411">411</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a0577721c5e714861b27ad4ff356980bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0577721c5e714861b27ad4ff356980bc">&#9670;&nbsp;</a></span>isRunning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::isRunning</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> is running. It will return true after <a class="el" href="classop_1_1_wrapper_t.html#a478b8bd7deb43322f220593552fe683d">exec()</a> or <a class="el" href="classop_1_1_wrapper_t.html#a8111d8cdb984e996410ace159a896992">start()</a> and before <a class="el" href="classop_1_1_wrapper_t.html#a061ea09aac902a8a44438feffd18998f">stop()</a>, and false otherwise. </p><dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> is running. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00460">460</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="aa89055f5cf4e762071479f5fec8d2faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89055f5cf4e762071479f5fec8d2faf">&#9670;&nbsp;</a></span>setDefaultMaxSizeQueues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::setDefaultMaxSizeQueues </td>
          <td>(</td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>defaultMaxSizeQueues</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It sets the maximum number of elements in the queue. For maximum speed, set to a very large number, but the trade-off would be:</p><ul>
<li>Latency will hugely increase.</li>
<li>The program might go out of RAM memory (so the computer might freeze). For minimum latency while keeping an optimal speed, set to -1, that will automatically detect the ideal number based on how many elements are connected to that queue. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultMaxSizeQueues</td><td>long long element with the maximum number of elements on the queue. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00474">474</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a0b502ef38ee46749733ae3dda7e5fd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b502ef38ee46749733ae3dda7e5fd31">&#9670;&nbsp;</a></span>setWorker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::setWorker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceop.html#a970a2a768a2ace81605b1558c9fdec18">WorkerType</a>&#160;</td>
          <td class="paramname"><em>workerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TWorker &amp;&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>workerOnNewThread</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an user-defined extra <a class="el" href="classop_1_1_worker.html">Worker</a> for a desired task (input, output, ...). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workerType</td><td>WorkerType to configure (e.g., Input, PreProcessing, PostProcessing, Output). </td></tr>
    <tr><td class="paramname">worker</td><td>TWorker to be added. </td></tr>
    <tr><td class="paramname">workerOnNewThread</td><td>Whether to add this TWorker on a new thread (if it is computationally demanding) or simply reuse existing threads (for light functions). Set to true if the performance time is unknown. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00300">300</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a8111d8cdb984e996410ace159a896992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8111d8cdb984e996410ace159a896992">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::start</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to start multi-threading. Similar to <a class="el" href="classop_1_1_wrapper_t.html#a478b8bd7deb43322f220593552fe683d">exec()</a>, but <a class="el" href="classop_1_1_wrapper_t.html#a8111d8cdb984e996410ace159a896992">start()</a> does not block the thread that calls the function. It just opens new threads, so it lets the user perform other tasks meanwhile on the calling thread. VERY IMPORTANT NOTE: if the GUI is selected and OpenCV is compiled with Qt support, this option will not work. Qt needs the main thread to plot visual results, so the final GUI (which uses OpenCV) would return an exception similar to: <code>QMetaMethod::invoke: Unable to invoke methods with return values in queued connections</code>. Use <a class="el" href="classop_1_1_wrapper_t.html#a478b8bd7deb43322f220593552fe683d">exec()</a> in that case. </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00429">429</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a061ea09aac902a8a44438feffd18998f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061ea09aac902a8a44438feffd18998f">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::stop</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to stop multi-threading. It can be called internally or externally. </p>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00447">447</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a79fa1a518495e1e3684f05943d1c04f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fa1a518495e1e3684f05943d1c04f8">&#9670;&nbsp;</a></span>tryEmplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::tryEmplace </td>
          <td>(</td>
          <td class="paramtype">TDatumsSP &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emplace (move) an element on the first (input) queue. Only valid if <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a288aae25bc408055f50c21c991903a44">ThreadManagerMode::Asynchronous</a> or <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a435b3ab344c03bfc0e4530a2e75f5e44">ThreadManagerMode::AsynchronousIn</a>. If the input queue is full or the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> was stopped, it will return false and not emplace it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>TDatumsSP element to be emplaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be emplaced. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00487">487</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a55af0ab1f0ea4329f2c0bb3feb92b835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55af0ab1f0ea4329f2c0bb3feb92b835">&#9670;&nbsp;</a></span>tryPop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::tryPop </td>
          <td>(</td>
          <td class="paramtype">TDatumsSP &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop (retrieve) an element from the last (output) queue. Only valid if <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a288aae25bc408055f50c21c991903a44">ThreadManagerMode::Asynchronous</a> or <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36ac68f8680ccf3a65dfcfc63356112c9f9">ThreadManagerMode::AsynchronousOut</a>. If the output queue is empty or the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> was stopped, it will return false and not retrieve it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>TDatumsSP element where the retrieved element will be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be retrieved. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00639">639</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a4d9396d4490b90f32a45d4a80d2cd5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9396d4490b90f32a45d4a80d2cd5c7">&#9670;&nbsp;</a></span>tryPush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::tryPush </td>
          <td>(</td>
          <td class="paramtype">const TDatumsSP &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push (copy) an element on the first (input) queue. Same as tryEmplace, but it copies the data instead of moving it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>TDatumsSP element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be pushed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00583">583</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="ae2c6cf519701c320ae53c597ae54a7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c6cf519701c320ae53c597ae54a7aa">&#9670;&nbsp;</a></span>waitAndEmplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::waitAndEmplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to waitAndEmplace(const TDatumsSP&amp; tDatums), but it takes a <a class="el" href="classop_1_1_matrix.html">Matrix</a> as input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td><a class="el" href="classop_1_1_matrix.html">Matrix</a> with the image to be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be emplaced. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00561">561</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a442ff1e4fec93ec28457f7c7c4b4bfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442ff1e4fec93ec28457f7c7c4b4bfbb">&#9670;&nbsp;</a></span>waitAndEmplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::waitAndEmplace </td>
          <td>(</td>
          <td class="paramtype">TDatumsSP &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emplace (move) an element on the first (input) queue. Similar to tryEmplace. However, if the input queue is full, it will wait until it can emplace it. If the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> class is stopped before adding the element, it will return false and not emplace it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>TDatumsSP element to be emplaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be emplaced. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00523">523</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a3c3b605e0787b55ffd00725c09a1cd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3b605e0787b55ffd00725c09a1cd53">&#9670;&nbsp;</a></span>waitAndPop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::waitAndPop </td>
          <td>(</td>
          <td class="paramtype">TDatumsSP &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop (retrieve) an element from the last (output) queue. Similar to tryPop. However, if the output queue is empty, it will wait until it can pop an element. If the <a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a> class is stopped before popping the element, it will return false and not retrieve it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>TDatumsSP element where the retrieved element will be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be retrieved. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00656">656</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="abcb907a2718260a14c0472279254df84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb907a2718260a14c0472279254df84">&#9670;&nbsp;</a></span>waitAndPush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::waitAndPush </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classop_1_1_wrapper_t.html#a0e0aea3f8bf81458c0662c46f4d345d5">waitAndPush(const TDatumsSP&amp; tDatums)</a>, but it takes a <a class="el" href="classop_1_1_matrix.html">Matrix</a> as input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td><a class="el" href="classop_1_1_matrix.html">Matrix</a> with the image to be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be pushed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00617">617</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<a id="a0e0aea3f8bf81458c0662c46f4d345d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0aea3f8bf81458c0662c46f4d345d5">&#9670;&nbsp;</a></span>waitAndPush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatum , typename TDatums , typename TDatumsSP , typename TWorker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper_t.html">op::WrapperT</a>&lt; TDatum, TDatums, TDatumsSP, TWorker &gt;::waitAndPush </td>
          <td>(</td>
          <td class="paramtype">const TDatumsSP &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push (copy) an element on the first (input) queue. Same as waitAndEmplace, but it copies the data instead of moving it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>TDatumsSP element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be pushed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrapper_8hpp_source.html#l00600">600</a> of file <a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/openpose/wrapper/<a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceop.html">op</a></li><li class="navelem"><a class="el" href="classop_1_1_wrapper_t.html">WrapperT</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
