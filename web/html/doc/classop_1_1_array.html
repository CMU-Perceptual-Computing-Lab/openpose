<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenPose: op::Array&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_doxygen_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenPose
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
   <div id="projectbrief">The first real-time multi-person system to jointly detect human body, hand, facial, and foot keypoints</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classop_1_1_array.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classop_1_1_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">op::Array&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a793b9851c7490bc98d4dd52020c0cd3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a793b9851c7490bc98d4dd52020c0cd3c">Array</a> (const int size)</td></tr>
<tr class="separator:a793b9851c7490bc98d4dd52020c0cd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c1ba1f7017b5aa8e0451079dd3a6d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a48c1ba1f7017b5aa8e0451079dd3a6d3">Array</a> (const std::vector&lt; int &gt; &amp;sizes={})</td></tr>
<tr class="separator:a48c1ba1f7017b5aa8e0451079dd3a6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac833fdcb245fcc3135ce65227bb9e4b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ac833fdcb245fcc3135ce65227bb9e4b2">Array</a> (const int size, const T value)</td></tr>
<tr class="separator:ac833fdcb245fcc3135ce65227bb9e4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ede0df7e535d2d3ac40d098541c27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a959ede0df7e535d2d3ac40d098541c27">Array</a> (const std::vector&lt; int &gt; &amp;sizes, const T value)</td></tr>
<tr class="separator:a959ede0df7e535d2d3ac40d098541c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd386050e94c29b3c4ee40cafcacc46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a9cd386050e94c29b3c4ee40cafcacc46">Array</a> (const int size, T *const dataPtr)</td></tr>
<tr class="separator:a9cd386050e94c29b3c4ee40cafcacc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90895562def04a81db0b3e7eaa3722c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a90895562def04a81db0b3e7eaa3722c7">Array</a> (const std::vector&lt; int &gt; &amp;sizes, T *const dataPtr)</td></tr>
<tr class="separator:a90895562def04a81db0b3e7eaa3722c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416e95541761c557c50b79b5e1b33389"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a416e95541761c557c50b79b5e1b33389">Array</a> (const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;array, const int index, const bool noCopy=false)</td></tr>
<tr class="separator:a416e95541761c557c50b79b5e1b33389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4e1f55747898d29aa13606ded9991f"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:afb4e1f55747898d29aa13606ded9991f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#afb4e1f55747898d29aa13606ded9991f">Array</a> (const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T2 &gt; &amp;array)</td></tr>
<tr class="separator:afb4e1f55747898d29aa13606ded9991f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a68cca98a3ebaf565f1e546eebd9f01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a5a68cca98a3ebaf565f1e546eebd9f01">Array</a> (const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>
<tr class="separator:a5a68cca98a3ebaf565f1e546eebd9f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8e006e0eea472485f37971330ecbab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a9c8e006e0eea472485f37971330ecbab">operator=</a> (const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>
<tr class="separator:a9c8e006e0eea472485f37971330ecbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7d854d63815e10e158fe889d17a88e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a7a7d854d63815e10e158fe889d17a88e">Array</a> (<a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&amp;array)</td></tr>
<tr class="separator:a7a7d854d63815e10e158fe889d17a88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae388368128afac05369172198911e05d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ae388368128afac05369172198911e05d">operator=</a> (<a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&amp;array)</td></tr>
<tr class="separator:ae388368128afac05369172198911e05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b95bf5488cccad3bce7413251b04de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ab0b95bf5488cccad3bce7413251b04de">clone</a> () const</td></tr>
<tr class="separator:ab0b95bf5488cccad3bce7413251b04de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e538b09e98bf0900163031602ed2ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a12e538b09e98bf0900163031602ed2ed">reset</a> (const int size)</td></tr>
<tr class="separator:a12e538b09e98bf0900163031602ed2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad0232daa69783cf2c8f7a0ff5b3b0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a0ad0232daa69783cf2c8f7a0ff5b3b0c">reset</a> (const std::vector&lt; int &gt; &amp;sizes={})</td></tr>
<tr class="separator:a0ad0232daa69783cf2c8f7a0ff5b3b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7183eb2f4e78a6941da3a2079b9ed32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ac7183eb2f4e78a6941da3a2079b9ed32">reset</a> (const int size, const T value)</td></tr>
<tr class="separator:ac7183eb2f4e78a6941da3a2079b9ed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2eeccd967cdf0900449649cb6f5afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#add2eeccd967cdf0900449649cb6f5afb">reset</a> (const std::vector&lt; int &gt; &amp;sizes, const T value)</td></tr>
<tr class="separator:add2eeccd967cdf0900449649cb6f5afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3d1a662f6c213da16ac87e53120fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ae0c3d1a662f6c213da16ac87e53120fc">reset</a> (const int size, T *const dataPtr)</td></tr>
<tr class="separator:ae0c3d1a662f6c213da16ac87e53120fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3252c38318d81a8b8fb6f71f4d4c2642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a3252c38318d81a8b8fb6f71f4d4c2642">reset</a> (const std::vector&lt; int &gt; &amp;sizes, T *const dataPtr)</td></tr>
<tr class="separator:a3252c38318d81a8b8fb6f71f4d4c2642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4b51216faaa967d81598a0cedcf78f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a9f4b51216faaa967d81598a0cedcf78f">setFrom</a> (const <a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;cvMat)</td></tr>
<tr class="separator:a9f4b51216faaa967d81598a0cedcf78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f09d11de753a741334ee8094296acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a28f09d11de753a741334ee8094296acb">setTo</a> (const T value)</td></tr>
<tr class="separator:a28f09d11de753a741334ee8094296acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa173085fa7ec7c7af3a443c617edd97a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#aa173085fa7ec7c7af3a443c617edd97a">empty</a> () const</td></tr>
<tr class="separator:aa173085fa7ec7c7af3a443c617edd97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4568f646a97fa8cea443b864d91a28df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a4568f646a97fa8cea443b864d91a28df">getSize</a> () const</td></tr>
<tr class="separator:a4568f646a97fa8cea443b864d91a28df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4123b36e0816793e206365397dd8f79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ab4123b36e0816793e206365397dd8f79">getSize</a> (const int index) const</td></tr>
<tr class="separator:ab4123b36e0816793e206365397dd8f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f26a48c35cde008970078a66ff6e5c7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a3f26a48c35cde008970078a66ff6e5c7">printSize</a> () const</td></tr>
<tr class="separator:a3f26a48c35cde008970078a66ff6e5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff0723f0bbd192248e602bfbb6956f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a5eff0723f0bbd192248e602bfbb6956f">getNumberDimensions</a> () const</td></tr>
<tr class="separator:a5eff0723f0bbd192248e602bfbb6956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee364306687e39e754117c98ad844157"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#aee364306687e39e754117c98ad844157">getVolume</a> () const</td></tr>
<tr class="separator:aee364306687e39e754117c98ad844157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed838d2b9933b6a80906d0e0db39742"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a5ed838d2b9933b6a80906d0e0db39742">getVolume</a> (const int indexA, const int indexB=-1) const</td></tr>
<tr class="separator:a5ed838d2b9933b6a80906d0e0db39742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38de9c4ba539b8134fcac91287722044"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a38de9c4ba539b8134fcac91287722044">getStride</a> () const</td></tr>
<tr class="separator:a38de9c4ba539b8134fcac91287722044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab033fba3d9140020dd89edb10fe8b109"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ab033fba3d9140020dd89edb10fe8b109">getStride</a> (const int index) const</td></tr>
<tr class="separator:ab033fba3d9140020dd89edb10fe8b109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4715967fd2b028a97fd30257e697275"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#af4715967fd2b028a97fd30257e697275">getPtr</a> ()</td></tr>
<tr class="separator:af4715967fd2b028a97fd30257e697275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e77d6926d1d344cf54c88036fc8a9c"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ac5e77d6926d1d344cf54c88036fc8a9c">getConstPtr</a> () const</td></tr>
<tr class="separator:ac5e77d6926d1d344cf54c88036fc8a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d749e637a7528325f86b80595a91d1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a85d749e637a7528325f86b80595a91d1">getPseudoConstPtr</a> () const</td></tr>
<tr class="separator:a85d749e637a7528325f86b80595a91d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b43d8d495a233c384a75a3f33eae75f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a9b43d8d495a233c384a75a3f33eae75f">getConstCvMat</a> () const</td></tr>
<tr class="separator:a9b43d8d495a233c384a75a3f33eae75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530010928025b3f64743505d732b1308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a530010928025b3f64743505d732b1308">getCvMat</a> ()</td></tr>
<tr class="separator:a530010928025b3f64743505d732b1308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40dc59e800d3c4cce623d560c0e0fad"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#aa40dc59e800d3c4cce623d560c0e0fad">operator[]</a> (const int index)</td></tr>
<tr class="separator:aa40dc59e800d3c4cce623d560c0e0fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1d5ce14d11caa3b92306ee677af4cc"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a0e1d5ce14d11caa3b92306ee677af4cc">operator[]</a> (const int index) const</td></tr>
<tr class="separator:a0e1d5ce14d11caa3b92306ee677af4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada0f1bd6e9eb73b4f977e62da536f58"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#aada0f1bd6e9eb73b4f977e62da536f58">operator[]</a> (const std::vector&lt; int &gt; &amp;indexes)</td></tr>
<tr class="separator:aada0f1bd6e9eb73b4f977e62da536f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e9514cfee78a3a0236c1a6265376d8"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ac4e9514cfee78a3a0236c1a6265376d8">operator[]</a> (const std::vector&lt; int &gt; &amp;indexes) const</td></tr>
<tr class="separator:ac4e9514cfee78a3a0236c1a6265376d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0afd5f447efbfc29efbeac62716eff"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at</a> (const int index)</td></tr>
<tr class="separator:a6e0afd5f447efbfc29efbeac62716eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a24dfa0d0f1f3769bf3bfcea47e2220"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a4a24dfa0d0f1f3769bf3bfcea47e2220">at</a> (const int index) const</td></tr>
<tr class="separator:a4a24dfa0d0f1f3769bf3bfcea47e2220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eebb6c34642cdf19ac74c7ed38d128b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a8eebb6c34642cdf19ac74c7ed38d128b">at</a> (const std::vector&lt; int &gt; &amp;indexes)</td></tr>
<tr class="separator:a8eebb6c34642cdf19ac74c7ed38d128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74dec8220582072f85fb3ec430238ce"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ae74dec8220582072f85fb3ec430238ce">at</a> (const std::vector&lt; int &gt; &amp;indexes) const</td></tr>
<tr class="separator:ae74dec8220582072f85fb3ec430238ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af488c66ddac6cb75f7690ba8207599ed"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#af488c66ddac6cb75f7690ba8207599ed">toString</a> () const</td></tr>
<tr class="separator:af488c66ddac6cb75f7690ba8207599ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class op::Array&lt; T &gt;</h3>

<p>Array&lt;T&gt;: The OpenPose Basic Raw Data Container This template class implements a multidimensional data array. It is our basic data container, analogous to Mat in OpenCV, Tensor in Torch/TensorFlow or Blob in Caffe. It wraps a <a class="el" href="classop_1_1_matrix.html">Matrix</a> and a std::shared_ptr, both of them pointing to the same raw data. I.e. they both share the same memory, so we can read and modify this data in both formats with no performance impact. Hence, it keeps high performance while adding high-level functions. </p>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00021">21</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a793b9851c7490bc98d4dd52020c0cd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793b9851c7490bc98d4dd52020c0cd3c">&#9670;&nbsp;</a></span>Array() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor + <a class="el" href="classop_1_1_array.html#a12e538b09e98bf0900163031602ed2ed">reset(const int size)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g., size = 5 is internally similar to <code>new T[5]</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48c1ba1f7017b5aa8e0451079dd3a6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c1ba1f7017b5aa8e0451079dd3a6d3">&#9670;&nbsp;</a></span>Array() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor + reset(const std::vector&lt;int&gt;&amp; size = {}). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g., size = {3, 5, 2} is internally similar to <code>new T[3*5*2]</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac833fdcb245fcc3135ce65227bb9e4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac833fdcb245fcc3135ce65227bb9e4b2">&#9670;&nbsp;</a></span>Array() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor + <a class="el" href="classop_1_1_array.html#ac7183eb2f4e78a6941da3a2079b9ed32">reset(const int size, const T value)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g., size = 5 is internally similar to <code>new T[5]</code>. </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a959ede0df7e535d2d3ac40d098541c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959ede0df7e535d2d3ac40d098541c27">&#9670;&nbsp;</a></span>Array() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor + <a class="el" href="classop_1_1_array.html#add2eeccd967cdf0900449649cb6f5afb">reset(const std::vector&lt;int&gt;&amp; size, const T value)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g., size = {3, 5, 2} is internally similar to: <code>new T[3*5*2]</code>. </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cd386050e94c29b3c4ee40cafcacc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd386050e94c29b3c4ee40cafcacc46">&#9670;&nbsp;</a></span>Array() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>dataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor, but it does not allocate memory, but rather use dataPtr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g., size = 5 is internally similar to <code>new T[5]</code>. </td></tr>
    <tr><td class="paramname">dataPtr</td><td>Pointer to the memory to be used by the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90895562def04a81db0b3e7eaa3722c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90895562def04a81db0b3e7eaa3722c7">&#9670;&nbsp;</a></span>Array() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>dataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor, but it does not allocate memory, but rather use dataPtr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g., size = {3, 5, 2} is internally similar to: <code>new T[3*5*2]</code>. </td></tr>
    <tr><td class="paramname">dataPtr</td><td>Pointer to the memory to be used by the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a416e95541761c557c50b79b5e1b33389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416e95541761c557c50b79b5e1b33389">&#9670;&nbsp;</a></span>Array() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>noCopy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array&lt;T&gt; with the original data array to slice. </td></tr>
    <tr><td class="paramname">index</td><td>indicates the index of the array to extract. </td></tr>
    <tr><td class="paramname">noCopy</td><td>indicates whether to perform a copy. Copy will never go to undefined behavior, however, if noCopy == true, then:<ol type="1">
<li>It is faster, as no data copy is involved, but...</li>
<li>If the <a class="el" href="classop_1_1_array.html">Array</a> array goes out of scope, then the resulting <a class="el" href="classop_1_1_array.html">Array</a> will provoke an undefined behavior.</li>
<li>If the returned <a class="el" href="classop_1_1_array.html">Array</a> is modified, the information in the <a class="el" href="classop_1_1_array.html">Array</a> array will also be. </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array&lt;T&gt; with the same dimension than array expect the first dimension being 1. E.g., if array is {p,k,m}, the resulting Array&lt;T&gt; is {1,k,m}. </dd></dl>

</div>
</div>
<a id="afb4e1f55747898d29aa13606ded9991f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4e1f55747898d29aa13606ded9991f">&#9670;&nbsp;</a></span>Array() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. It manually copies the Array&lt;T2&gt; into the new Array&lt;T&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array&lt;T2&gt; with a format T2 different to the current <a class="el" href="classop_1_1_array.html">Array</a> type T. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00096">96</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a5a68cca98a3ebaf565f1e546eebd9f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a68cca98a3ebaf565f1e546eebd9f01">&#9670;&nbsp;</a></span>Array() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. It performs <code>fast copy</code>: For performance purpose, copying a Array&lt;T&gt; or <a class="el" href="structop_1_1_datum.html">Datum</a> or cv::Mat just copies the reference, it still shares the same internal data. Modifying the copied element will modify the original one. Use <a class="el" href="classop_1_1_array.html#ab0b95bf5488cccad3bce7413251b04de">clone()</a> for a slower but real copy, similarly to cv::Mat and Array&lt;T&gt;. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><a class="el" href="classop_1_1_array.html">Array</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a7d854d63815e10e158fe889d17a88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7d854d63815e10e158fe889d17a88e">&#9670;&nbsp;</a></span>Array() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor. It destroys the original <a class="el" href="classop_1_1_array.html">Array</a> to be moved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><a class="el" href="classop_1_1_array.html">Array</a> to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e0afd5f447efbfc29efbeac62716eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0afd5f447efbfc29efbeac62716eff">&#9670;&nbsp;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at()</a> function Same functionality as <a class="el" href="classop_1_1_array.html#aa40dc59e800d3c4cce623d560c0e0fad">operator[](const int index)</a>, but it always check whether the indexes are within the data bounds. Otherwise, it will throw an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A editable reference to the data on the desired index location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00422">422</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a4a24dfa0d0f1f3769bf3bfcea47e2220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a24dfa0d0f1f3769bf3bfcea47e2220">&#9670;&nbsp;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at()</a> function Same functionality as <a class="el" href="classop_1_1_array.html#a0e1d5ce14d11caa3b92306ee677af4cc">operator[](const int index) const</a>, but it always check whether the indexes are within the data bounds. Otherwise, it will throw an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-editable reference to the data on the desired index location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00434">434</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a8eebb6c34642cdf19ac74c7ed38d128b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eebb6c34642cdf19ac74c7ed38d128b">&#9670;&nbsp;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at()</a> function Same functionality as <a class="el" href="classop_1_1_array.html#aada0f1bd6e9eb73b4f977e62da536f58">operator[](const std::vector&lt;int&gt;&amp; indexes)</a>, but it always check whether the indexes are within the data bounds. Otherwise, it will throw an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>Vector with the desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A editable reference to the data on the desired index location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00446">446</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="ae74dec8220582072f85fb3ec430238ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74dec8220582072f85fb3ec430238ce">&#9670;&nbsp;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at()</a> function Same functionality as <a class="el" href="classop_1_1_array.html#ac4e9514cfee78a3a0236c1a6265376d8">operator[](const std::vector&lt;int&gt;&amp; indexes) const</a>, but it always check whether the indexes are within the data bounds. Otherwise, it will throw an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>Vector with the desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-editable reference to the data on the desired index location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00458">458</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="ab0b95bf5488cccad3bce7413251b04de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b95bf5488cccad3bce7413251b04de">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">Array</a>&lt;T&gt; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clone function. Similar to cv::Mat::clone and <a class="el" href="structop_1_1_datum.html#ad137a102ef753734a9413762d72e6d46">Datum::clone</a>. It performs a real but slow copy of the data, i.e., even if the copied element is modified, the original one is not. </p><dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classop_1_1_array.html">Array</a>. </dd></dl>

</div>
</div>
<a id="aa173085fa7ec7c7af3a443c617edd97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa173085fa7ec7c7af3a443c617edd97a">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether memory has been allocated. </p><dl class="section return"><dt>Returns</dt><dd>True if no memory has been allocated, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00228">228</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a9b43d8d495a233c384a75a3f33eae75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b43d8d495a233c384a75a3f33eae75f">&#9670;&nbsp;</a></span>getConstCvMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classop_1_1_matrix.html">Matrix</a>&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getConstCvMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classop_1_1_matrix.html">Matrix</a> wrapper to the data. It forbids the data to be modified. OpenCV only admits unsigned char, signed char, int, float &amp; double. If the T class is not supported by OpenCV, it will throw an error. Note: Array&lt;T&gt; does not return an editable <a class="el" href="classop_1_1_matrix.html">Matrix</a> because some OpenCV functions reallocate memory and it would not longer point to the Array&lt;T&gt; instance. If you want to perform some OpenCV operation on the <a class="el" href="classop_1_1_array.html">Array</a> data, you can use: editedCvMat = array.getConstCvMat().<a class="el" href="classop_1_1_array.html#ab0b95bf5488cccad3bce7413251b04de">clone()</a>; // modify data array.setFrom(editedCvMat) </p><dl class="section return"><dt>Returns</dt><dd>A const <a class="el" href="classop_1_1_matrix.html">Matrix</a> pointing to the data. </dd></dl>

</div>
</div>
<a id="ac5e77d6926d1d344cf54c88036fc8a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e77d6926d1d344cf54c88036fc8a9c">&#9670;&nbsp;</a></span>getConstPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getConstPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classop_1_1_array.html#af4715967fd2b028a97fd30257e697275">getPtr()</a>, but it forbids the data to be edited. </p><dl class="section return"><dt>Returns</dt><dd>A raw const pointer to the data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00319">319</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a530010928025b3f64743505d732b1308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530010928025b3f64743505d732b1308">&#9670;&nbsp;</a></span>getCvMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_matrix.html">Matrix</a>&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getCvMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogous to getConstCvMat, but in this case it returns a editable <a class="el" href="classop_1_1_matrix.html">Matrix</a>. Very important: Only allowed functions which do not provoke data reallocation. E.g., resizing functions will not work and they would provoke an undefined behavior and/or execution crashes. </p><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classop_1_1_matrix.html">Matrix</a> pointing to the data. </dd></dl>

</div>
</div>
<a id="a5eff0723f0bbd192248e602bfbb6956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff0723f0bbd192248e602bfbb6956f">&#9670;&nbsp;</a></span>getNumberDimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getNumberDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of dimensions, equivalent to <a class="el" href="classop_1_1_array.html#a4568f646a97fa8cea443b864d91a28df">getSize()</a>.size(). </p><dl class="section return"><dt>Returns</dt><dd>The number of dimensions. If no memory is allocated, it returns 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00262">262</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a85d749e637a7528325f86b80595a91d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d749e637a7528325f86b80595a91d1">&#9670;&nbsp;</a></span>getPseudoConstPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getPseudoConstPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classop_1_1_array.html#ac5e77d6926d1d344cf54c88036fc8a9c">getConstPtr()</a>, but it allows the data to be edited. This function is only implemented for Pybind11 usage. </p><dl class="section return"><dt>Returns</dt><dd>A raw pointer to the data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00329">329</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="af4715967fd2b028a97fd30257e697275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4715967fd2b028a97fd30257e697275">&#9670;&nbsp;</a></span>getPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a raw pointer to the data. Similar to: std::shared_ptr::get(). Note: if you modify the pointer data, you will directly modify it in the Array&lt;T&gt; instance too. If you know you do not want to modify the data, then use <a class="el" href="classop_1_1_array.html#ac5e77d6926d1d344cf54c88036fc8a9c">getConstPtr()</a> instead. </p><dl class="section return"><dt>Returns</dt><dd>A raw pointer to the data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00310">310</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a4568f646a97fa8cea443b864d91a28df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4568f646a97fa8cea443b864d91a28df">&#9670;&nbsp;</a></span>getSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector with the size of each dimension allocated. </p><dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;int&gt; with the size of each dimension. If no memory has been allocated, it will return an empty std::vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00238">238</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="ab4123b36e0816793e206365397dd8f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4123b36e0816793e206365397dd8f79">&#9670;&nbsp;</a></span>getSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getSize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector with the size of the desired dimension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Dimension to check its size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the desired dimension. It will return 0 if the requested dimension is higher than the number of dimensions. </dd></dl>

</div>
</div>
<a id="a38de9c4ba539b8134fcac91287722044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38de9c4ba539b8134fcac91287722044">&#9670;&nbsp;</a></span>getStride() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the stride or step size of the array. E.g., given and Array&lt;T&gt; of size 5x3, <a class="el" href="classop_1_1_array.html#a38de9c4ba539b8134fcac91287722044">getStride()</a> would return the following vector: {5x3sizeof(T), 3sizeof(T), sizeof(T)}. </p>

</div>
</div>
<a id="ab033fba3d9140020dd89edb10fe8b109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab033fba3d9140020dd89edb10fe8b109">&#9670;&nbsp;</a></span>getStride() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getStride </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the stride or step size of the array at the index-th dimension. E.g., given and Array&lt;T&gt; of size 5x3, getStride(2) would return sizeof(T). </p>

</div>
</div>
<a id="aee364306687e39e754117c98ad844157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee364306687e39e754117c98ad844157">&#9670;&nbsp;</a></span>getVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of elements allocated, equivalent to multiply all the components from <a class="el" href="classop_1_1_array.html#a4568f646a97fa8cea443b864d91a28df">getSize()</a>. E.g., for a Array&lt;T&gt; of size = {2,5,3}, the volume or total number of elements is: 2x5x3 = 30. </p><dl class="section return"><dt>Returns</dt><dd>The total volume of the allocated data. If no memory is allocated, it returns 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00272">272</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a5ed838d2b9933b6a80906d0e0db39742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed838d2b9933b6a80906d0e0db39742">&#9670;&nbsp;</a></span>getVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getVolume </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indexA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indexB</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classop_1_1_array.html#aee364306687e39e754117c98ad844157">getVolume()</a>, but in this case it just returns the volume between the desired dimensions. E.g., for a Array&lt;T&gt; of size = {2,5,3}, the volume or total number of elements for getVolume(1,2) is 5x3 = 15. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexA</td><td>Dimension where to start. </td></tr>
    <tr><td class="paramname">indexB</td><td>Dimension where to stop. If indexB == -1, then it will take up to the last dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total volume of the allocated data between the desired dimensions. If the index are out of bounds, it throws an error. </dd></dl>

</div>
</div>
<a id="ae388368128afac05369172198911e05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae388368128afac05369172198911e05d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move assignment. Similar to <a class="el" href="classop_1_1_array.html#a7a7d854d63815e10e158fe889d17a88e">Array&lt;T&gt;(Array&lt;T&gt;&amp;&amp; array)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><a class="el" href="classop_1_1_array.html">Array</a> to be moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classop_1_1_array.html">Array</a>. </dd></dl>

</div>
</div>
<a id="a9c8e006e0eea472485f37971330ecbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8e006e0eea472485f37971330ecbab">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy assignment. Similar to <a class="el" href="classop_1_1_array.html#a5a68cca98a3ebaf565f1e546eebd9f01">Array&lt;T&gt;(const Array&lt;T&gt;&amp; array)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><a class="el" href="classop_1_1_array.html">Array</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classop_1_1_array.html">Array</a>. </dd></dl>

</div>
</div>
<a id="aa40dc59e800d3c4cce623d560c0e0fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40dc59e800d3c4cce623d560c0e0fad">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[] operator Similar to the [] operator for raw pointer data. If debug mode is enabled, then it will check that the desired index is in the data range, and it will throw an exception otherwise (similar to the at operator). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A editable reference to the data on the desired index location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00365">365</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a0e1d5ce14d11caa3b92306ee677af4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1d5ce14d11caa3b92306ee677af4cc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[] operator Same functionality as <a class="el" href="classop_1_1_array.html#aa40dc59e800d3c4cce623d560c0e0fad">operator[](const int index)</a>, but it forbids modifying the value. Otherwise, const functions would not be able to call the [] operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-editable reference to the data on the desired index location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00381">381</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="aada0f1bd6e9eb73b4f977e62da536f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada0f1bd6e9eb73b4f977e62da536f58">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[] operator Same functionality as <a class="el" href="classop_1_1_array.html#aa40dc59e800d3c4cce623d560c0e0fad">operator[](const int index)</a>, but it lets the user introduce the multi-dimensional index. E.g., given a (10 x 10 x 10) array, array[11] is equivalent to array[{1,1,0}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>Vector with the desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A editable reference to the data on the desired index location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00398">398</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="ac4e9514cfee78a3a0236c1a6265376d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e9514cfee78a3a0236c1a6265376d8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[] operator Same functionality as <a class="el" href="classop_1_1_array.html#aada0f1bd6e9eb73b4f977e62da536f58">operator[](const std::vector&lt;int&gt;&amp; indexes)</a>, but it forbids modifying the value. Otherwise, const functions would not be able to call the [] operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>Vector with the desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-editable reference to the data on the desired index location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8hpp_source.html#l00410">410</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a id="a3f26a48c35cde008970078a66ff6e5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f26a48c35cde008970078a66ff6e5c7">&#9670;&nbsp;</a></span>printSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::printSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string with the size of each dimension allocated. </p><dl class="section return"><dt>Returns</dt><dd>A std::stringwith the size of each dimension. If no memory has been allocated, it will return an empty string. </dd></dl>

</div>
</div>
<a id="a12e538b09e98bf0900163031602ed2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e538b09e98bf0900163031602ed2ed">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. It allocates the required space for the memory (it does not initialize that memory). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g., size = 5 is internally similar to <code>new T[5]</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7183eb2f4e78a6941da3a2079b9ed32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7183eb2f4e78a6941da3a2079b9ed32">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. Similar to <a class="el" href="classop_1_1_array.html#a12e538b09e98bf0900163031602ed2ed">reset(const int size)</a>, but initializing the data to the value specified by the second argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g., size = 5 is internally similar to <code>new T[5]</code>. </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0c3d1a662f6c213da16ac87e53120fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c3d1a662f6c213da16ac87e53120fc">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>dataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. Equivalent to default constructor, but it does not allocate memory, but rather use dataPtr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g., size = 5 is internally similar to <code>new T[5]</code>. </td></tr>
    <tr><td class="paramname">dataPtr</td><td>Pointer to the memory to be used by the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add2eeccd967cdf0900449649cb6f5afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2eeccd967cdf0900449649cb6f5afb">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. Similar to <a class="el" href="classop_1_1_array.html#a0ad0232daa69783cf2c8f7a0ff5b3b0c">reset(const std::vector&lt;int&gt;&amp; size)</a>, but initializing the data to the value specified by the second argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g., size = {3, 5, 2} is internally similar to <code>new T[3*5*2]</code>. </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3252c38318d81a8b8fb6f71f4d4c2642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3252c38318d81a8b8fb6f71f4d4c2642">&#9670;&nbsp;</a></span>reset() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>dataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. Equivalent to default constructor, but it does not allocate memory, but rather use dataPtr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g., size = {3, 5, 2} is internally similar to: <code>new T[3*5*2]</code>. </td></tr>
    <tr><td class="paramname">dataPtr</td><td>Pointer to the memory to be used by the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ad0232daa69783cf2c8f7a0ff5b3b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad0232daa69783cf2c8f7a0ff5b3b0c">&#9670;&nbsp;</a></span>reset() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. Similar to <a class="el" href="classop_1_1_array.html#a12e538b09e98bf0900163031602ed2ed">reset(const int size)</a>, but it allocates a multi-dimensional array of dimensions each of the values of the argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g., size = {3, 5, 2} is internally similar to <code>new T[3*5*2]</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f4b51216faaa967d81598a0cedcf78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4b51216faaa967d81598a0cedcf78f">&#9670;&nbsp;</a></span>setFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::setFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>cvMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. It internally allocates memory and copies the data of the argument to the <a class="el" href="classop_1_1_array.html">Array</a> allocated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cvMat</td><td><a class="el" href="classop_1_1_matrix.html">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28f09d11de753a741334ee8094296acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f09d11de753a741334ee8094296acb">&#9670;&nbsp;</a></span>setTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::setTo </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. It internally assigns all the allocated memory to the value indicated by the argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af488c66ddac6cb75f7690ba8207599ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af488c66ddac6cb75f7690ba8207599ed">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns a string with the whole array data. Useful for debugging. The format is: values separated by a space, and a enter for each dimension. E.g., For the <a class="el" href="classop_1_1_array.html">Array</a>{2, 2, 3}, it will print: <a class="el" href="classop_1_1_array.html#af488c66ddac6cb75f7690ba8207599ed">Array&lt;T&gt;::toString()</a>: x1 x2 x3 x4 x5 x6</p>
<p>x7 x8 x9 x10 x11 x12 </p><dl class="section return"><dt>Returns</dt><dd>A string with the array values in the above format. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/openpose/core/<a class="el" href="array_8hpp_source.html">array.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceop.html">op</a></li><li class="navelem"><a class="el" href="classop_1_1_array.html">Array</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
