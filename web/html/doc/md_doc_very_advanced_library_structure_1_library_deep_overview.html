<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenPose: OpenPose Very Advanced Doc - Library Structure - Deep Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_doxygen_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenPose
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
   <div id="projectbrief">The first real-time multi-person system to jointly detect human body, hand, facial, and foot keypoints</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doc_very_advanced_library_structure_1_library_deep_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">OpenPose Very Advanced Doc - Library Structure - Deep Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Note: Read <a class="el" href="md_doc_very_advanced_library_structure_0_index.html">doc/very_advanced/library_structure/0_index.md</a> before this page.</p>
<h1><a class="anchor" id="autotoc_md256"></a>
Modules Diagram</h1>
<p><img src="./UML/1_0_0rc3/UML.png" alt="" width="720" class="inline"/> </p>
<h1><a class="anchor" id="autotoc_md257"></a>
Debugging C++ Code</h1>
<h2><a class="anchor" id="autotoc_md258"></a>
Finding Segmentation Faults</h2>
<p>This is the faster method to debug a segmentation fault problem. Usual scenario: You are editing OpenPose source code and suddenly OpenPose returns segmentation fault when executed. In order to find where it occurs:</p>
<ol type="1">
<li>Select one of the 2 options:<ol type="a">
<li>Switch to debug mode.</li>
<li>Go to <code><a class="el" href="error_and_log_8hpp.html">openpose/utilities/errorAndLog.hpp</a></code> and modify <code>dLog</code>:<ol type="i">
<li>Comment <code>#ifndef NDEBUG</code> and its else and endif.</li>
</ol>
</li>
</ol>
</li>
<li>Call OpenPose with <code>--logging_level 0 --disable_multi_thread</code>.</li>
<li>At this point you have an idea of in which file class the segmentation fault is coming from. Now you can further isolate the error by iteratively adding the following line all over the code until you find the exact position of the segmentation fault: <code>opLog("", Priority::Low, __LINE__, __FUNCTION__, __FILE__);</code></li>
<li>After you have found the segmentation fault, remember to remove all the extra <code><a class="el" href="namespaceop.html#aa72861fea0671209aca1ea5fa385891a">opLog()</a></code> calls that you temporarily added.</li>
</ol>
<h1><a class="anchor" id="autotoc_md259"></a>
Accuracy</h1>
<h2><a class="anchor" id="autotoc_md260"></a>
Checking OpenPose Accuracy Quantitatively</h2>
<ol type="1">
<li>Download OpenPose training code: <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose_train">https://github.com/CMU-Perceptual-Computing-Lab/openpose_train</a></li>
<li>Download val2017 set from COCO: <a href="http://images.cocodataset.org/zips/val2017.zip">http://images.cocodataset.org/zips/val2017.zip</a></li>
<li>Get JSONs in OpenPose: examples/tests/pose_accuracy_coco_val.sh</li>
<li>Get accuracy (Matlab): validation/f_getValidations.m</li>
</ol>
<h2><a class="anchor" id="autotoc_md261"></a>
Checking Ground-Truth Labels</h2>
<p>From the <a href="http://cocodataset.org/#download">COCO dataset</a>:</p><ol type="1">
<li>Download 2014 or 2017 Train/Val annotations.</li>
<li>Download the <a href="https://github.com/cocodataset/cocoapi">COCO API</a>.</li>
<li>With the COCO API (either Python, Matlab, or LUA ones), you can check any image with the image ID (equivalent to the number in the image name).</li>
</ol>
<h1><a class="anchor" id="autotoc_md262"></a>
OpenPose Coding Style</h1>
<ol type="1">
<li>Error-prone mistakes:<ol type="a">
<li>Do never use std::mutex.lock and/or std::mutex.unlock. Use std::unique_lock&lt;std::mutex&gt; if unlock required or std::lock_guard&lt;std::mutex&gt; otherwise.</li>
<li>Do never use the new keyword with std::shared_ptr, but rather: std::make_shared&lt;&gt;.</li>
</ol>
</li>
<li>Naming:<ol type="a">
<li>Class parameters should start with <code>m</code>, class pointers with <code>p</code>, shared_ptrs with <code>sp</code>, unique_ptrs with <code>up</code>, static parameters with <code>s</code>.</li>
<li>Function and class parameters coding style is the same other than the previous point.</li>
<li>Any parameters should not contain special characters, simply letters and numbers (preferred only letters) separated with upper case. E.g., <code>mThisIsAParameter</code>, <code>thisIsAParameter</code>.</li>
<li>In addition, the names should be self-explanatory and not abbreviated. Good examples: <code>counter</code>, <code>thisIs</code>. Bad examples: <code>ctr</code>, <code>var</code>.</li>
</ol>
</li>
<li>Length:<ol type="a">
<li>Lines should contain up to 120 characters.</li>
</ol>
</li>
<li>Comments:<ol type="a">
<li>Only <code>//</code> comments are allowed in the code, <code>/* */</code> should not be used.</li>
<li>There should be a (at least) 1-line comment for each block of code inside each function.</li>
</ol>
</li>
<li>Loops and statements:<ol type="a">
<li>There should be a space between the keyword (<code>if</code>, <code>for</code>, etc) and the parenthesis, e.g., <code>if (true)</code>. Wrong: <code>if(true)</code>. Note: So they can be easily located with Ctrl + F.</li>
<li>Braces should be added in the following line with respect to the loop/statement keyword. See example in point 3.</li>
<li>1-line loops/statements should not contain braces. E.g., <div class="fragment"><div class="line">if (booleanParameter)</div>
<div class="line">    anotherParameter = 25;</div>
<div class="line">else</div>
<div class="line">{</div>
<div class="line">    anotherParameter = 2;</div>
<div class="line">    differentParameter = 3;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
</li>
<li>Includes:<ol type="a">
<li>There cannot be any include to a 3rd party in the headers (other than OpenCV core: <code>opencv2/core/core.hpp</code>).<ol type="i">
<li>PImpl idiom can be checked (e.g., in <code><a class="el" href="pose_extractor_caffe_8hpp.html">include/openpose/pose/poseExtractorCaffe.hpp</a></code>) for an idea of how to avoid it.</li>
<li>Otherwise the defining class examples in <code><a class="el" href="macros_8hpp.html">include/openpose/core/macros.hpp</a></code> (point 1 is highly preferred).</li>
</ol>
</li>
<li>They should be sorted in this order:<ol type="i">
<li>Std libraries.</li>
<li>OS libraries.</li>
<li>3rd party libraries (e.g., Caffe, OpenCV).</li>
<li>OpenPose libraries.</li>
<li>If it is a cpp file, the last one should be its own hpp.</li>
</ol>
</li>
<li>Inside each of the previous groups, it should be sorted alphabetically.</li>
</ol>
</li>
<li>Functions arguments:<ol type="a">
<li>It should first include the variables to be edited, and secondly the const variables.</li>
<li>Any variable that is not gonna be modified must be added with <code>const</code>.</li>
</ol>
</li>
<li>Pointers:<ol type="a">
<li>Pointers must be avoided if possible.</li>
<li>If a pointer must be used, std::unique_ptr must be always be used.</li>
<li>If the pointer must be shared, then std::shared_ptr.</li>
<li>No <code>delete</code> keyword is allowed in OpenPose.</li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md263"></a>
Main Modules</h1>
<p>In order to use and/or slightly extend the OpenPose library, we try to explain the 2 main components on this section. <a href="UML/">doc/very_advanced/library_structure/UML</a> contains the class diagram of all these modules.</p>
<ol type="1">
<li>The basic module: <code>core</code>.</li>
<li>The multi-threading module: <code>thread</code>.</li>
<li>The multi-person keypoint detection module: <code>pose</code>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md264"></a>
Basic Module: &lt;tt&gt;core&lt;/tt&gt;</h1>
<h2><a class="anchor" id="autotoc_md265"></a>
Array&lt;T&gt; - The OpenPose Basic Raw Data Container</h2>
<p>This template class implements a multidimensional data array. It is our basic data container, analogous to <code>cv::Mat</code> in OpenCV, Tensor in Torch and TensorFlow or Blob in Caffe. It wraps a <code>cv::Mat</code> and a <code>std::shared_ptr</code>, both of them pointing to the same raw data. I.e. they both share the same memory, so we can read this data in both formats, while there is no performance impact. For instance, <code><a class="el" href="structop_1_1_datum.html">op::Datum</a></code> has several <code><a class="el" href="classop_1_1_array.html">op::Array</a>&lt;float&gt;</code>, for instance the <code><a class="el" href="structop_1_1_datum.html">op::Datum</a>&lt;float&gt; pose</code> with the pose data.</p>
<h3><a class="anchor" id="autotoc_md266"></a>
Construction And Data allocation</h3>
<p>There are 4 different ways to allocate the memory:</p>
<ol type="1">
<li>The constructor <code>Array(const std::vector&lt;int&gt;&amp; size)</code>, which calls <code>reset(size)</code>.</li>
<li>The constructor <code>Array(const int size)</code>, which calls <code>reset(size)</code>.</li>
<li>The <code>reset(const std::vector&lt;int&gt;&amp; size)</code> function: It allocates the memory indicated for size. The allocated memory equals the product of all elements in the size vector. Internally, it is saved as a 1-D std::shared_ptr&lt;T[]&gt;.</li>
<li>The <code>reset(const int size)</code> function: equivalent for 1-dimension data (i.e., vector).</li>
<li>The <code>setFrom(const cv::Mat&amp; cvMat)</code> function: It calls <code>reset()</code> and copies the data from <code>cvMat</code>.</li>
</ol>
<h3><a class="anchor" id="autotoc_md267"></a>
Data access</h3>
<p>The data can be access as a raw pointer, shared pointer or <code>cv::Mat</code>. So given your <code>Array&lt;T&gt;</code> array:</p>
<ol type="1">
<li>Similar to the std::vector: <code>array[index]</code> or <code>array.at(index)</code>. If the code is in debug mode, they both has the same functionality. In release mode, the only difference is that the <code>at</code> function checks whether the index is within the limits of the data.</li>
<li>As <code>const cv::Mat</code>: <code>array.getConstCvMat()</code>. We do not allow to directly modify the <code>cv::Mat</code>, since some operations might change the dimensional size of the data. If you want to do so, you can clone this <code>cv::Mat</code>, perform any desired operation, and copy it back to the array class with <code>setFrom()</code>.</li>
<li>As raw pointer: <code>T* getPtr()</code> and <code>const T* const getConstPtr()</code>. Similar to std:: and std::shared_ptr::get(). For instance, CUDA code usually requires raw pointers to access its data.</li>
</ol>
<h3><a class="anchor" id="autotoc_md268"></a>
Dimensionality Information</h3>
<p>There are several functions to get information about the allocated data:</p>
<ol type="1">
<li><code>bool empty()</code>: Similar to <code>cv::Mat::empty()</code>. It checks whether internal data has been allocated.</li>
<li><code>std::vector&lt;int&gt; getSize()</code>: It returns the size of each dimension.</li>
<li><code>int getSize(const int index)</code>: It returns the size of the <code>index</code> dimension.</li>
<li><code>size_t getNumberDimensions()</code>: It returns the number of dimensions (i.e., getSize().size()).</li>
<li><code>size_t getVolume()</code>: It returns the total internal number of T objects, i.e., the product of all dimensions size.</li>
</ol>
<h2><a class="anchor" id="autotoc_md269"></a>
Datum - The OpenPose Basic Piece of Information Between Threads</h2>
<p>The <code>Datum</code> class has all the variables that our Workers need to share to each other. The user can inherit from <code><a class="el" href="structop_1_1_datum.html">op::Datum</a></code> in order to add extra functionality (e.g., if he want to add new Workers and they require extra information between them). We highly recommend not to modify the <code><a class="el" href="structop_1_1_datum.html">op::Datum</a></code> source code. Instead, just inherit it and tell the Workers and <code>ThreadManager</code> to use your inherited class. No changes are needed in the OpenPose source code for this task. </p><div class="fragment"><div class="line">UserDatum : public op::Datum {/* op::Datum + extra variables */}</div>
<div class="line"> </div>
<div class="line">// Worker and ThreadManager example initialization</div>
<div class="line">op::WGui&lt;std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;UserDatum&gt;&gt;&gt; userGUI(/* constructor arguments */);</div>
<div class="line">op::ThreadManager&lt;std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;UserDatum&gt;&gt;&gt; userThreadManager;</div>
</div><!-- fragment --><p>Since <code>UserDatum</code> inherits from <code><a class="el" href="structop_1_1_datum.html">op::Datum</a></code>, all the original OpenPose code will compile and run with your inherited version of <code><a class="el" href="structop_1_1_datum.html">op::Datum</a></code>.</p>
<h1><a class="anchor" id="autotoc_md270"></a>
Multi-Threading Module - &lt;tt&gt;thread&lt;/tt&gt;</h1>
<h2><a class="anchor" id="autotoc_md271"></a>
The ThreadManager&lt;T&gt; Template Class</h2>
<p>It manages and automates the multi-threading configuration and execution. The user just needs to add the desired Worker&lt;T&gt; classes to be executed and the parallelization mode, and this class will take care of it.</p>
<h3><a class="anchor" id="autotoc_md272"></a>
Constructor</h3>
<p>Just call <code><a class="el" href="classop_1_1_thread_manager.html">op::ThreadManager</a>&lt;TypedefDatumsSP&gt; threadManager</code>.</p>
<h3><a class="anchor" id="autotoc_md273"></a>
Adding a Worker Sequence</h3>
<p>There are 4 ways to add sequence of workers:</p>
<ol type="1">
<li><code>void add(const std::vector&lt;std::tuple&lt;unsigned long long, std::vector&lt;TWorker&gt;, unsigned long long, unsigned long long&gt;&gt;&amp; threadWorkerQueues)</code>.</li>
<li><code>void add(const std::vector&lt;std::tuple&lt;unsigned long long, TWorker, unsigned long long, unsigned long long&gt;&gt;&amp; threadWorkerQueues)</code>.</li>
<li><code>void add(const unsigned long long threadId, const std::vector&lt;TWorker&gt;&amp; tWorkers, const unsigned long long queueInId, const unsigned long long queueOutId)</code>.</li>
<li><code>void add(const unsigned long long threadId, const TWorker&amp; tWorker, const unsigned long long queueInId, const unsigned long long queueOutId)</code>.</li>
</ol>
<h3><a class="anchor" id="autotoc_md274"></a>
Threading Configuration Modes</h3>
<p>There are 3 basic configuration modes: single-threading, multi-threading and smart multi-threading (mix of single- and multi-threading):</p>
<ol type="1">
<li>Single-threading, with 2 variations:<ol type="a">
<li>Just call <code>threadManager.add(0, std::vector&lt;TypedefWorker&gt; VECTOR_WITH_ALL_WORKERS, 0, 1);</code></li>
<li>Add the workers one by one, but keeping the same threadId: ``` auto threadId = 0; auto queueIn = 0; auto queueOut = 0; threadManager.add(threadId, {wDatumProducer, wCvMatToOpInput}, queueIn++, queueOut++); // Thread 0, queues 0 -&gt; 1 threadManager.add(threadId, wPose, queueIn++, queueOut++); // Thread 0, queues 1 -&gt; 2 ```</li>
</ol>
</li>
<li>Multi-threading: Just increase the thread id for each new sequence: ``` auto threadId = 0; auto queueIn = 0; auto queueOut = 0; threadManager.add(threadId++, wDatumProducer, queueIn++, queueOut++); // Thread 0, queues 0 -&gt; 1 threadManager.add(threadId++, wCvMatToOpInput}, queueIn++, queueOut++); // Thread 1, queues 1 -&gt; 2 threadManager.add(threadId++, wPose, queueIn++, queueOut++); // Thread 2, queues 3 -&gt; 3 ```</li>
<li>Smart multi-threading: Some classes are much more faster than others (e.g., pose estimation takes ~100 ms while extracting frames from a video only ~10 ms). In addition, any machine has a limited number of threads. Therefore, the library allows the user to merge the faster threads in order to potentially speed up the code. Check the <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose/blob/master/examples/openpose/openpose.cpp">command line demo</a> too see a more complete example. ``` auto threadId = 0; auto queueIn = 0; auto queueOut = 0; threadManager.add(threadId++, {wDatumProducer, wCvMatToOpInput}, queueIn++, queueOut++); // Thread 0, queues 0 -&gt; 1, 2 workers merged together into 1 thread threadManager.add(threadId++, wPose, queueIn++, queueOut++); // Thread 1, queues 1 -&gt; 2, 1 worker ```</li>
</ol>
<h3><a class="anchor" id="autotoc_md275"></a>
Thread Id:</h3>
<p>In order to have X different threads, you just need X different thread ids in the <code>add()</code> function. There should not be any missing thread or queue id. I.e., when <code>start</code> is called, all the thread ids from 0 to max_thread_id must have been added with the <code>add()</code> function, as well as all queue ids from 0 to the maximum queue id introduced.</p>
<p>The threads will be started following the thread id order (first the lowest id, last the highest one). In practice, thread id ordering might negatively affect the program execution by adding some lag. I.e., if the thread ids are assigned in complete opposite order to the temporal order of the Workers (e.g., first the GUI and lastly the webcam reader), then during the first few iterations the GUI Worker will have an empty queue until all other Workers have processed at least one frame.</p>
<p>Within each thread, the Workers are executed in the order that they have been added to <code>ThreadManager</code> by the <code>add()</code> function.</p>
<h3><a class="anchor" id="autotoc_md276"></a>
Queue Id:</h3>
<p>In addition, each queue id is forced to be the input and output of at least 1 Worker sequence. Special cases are the queue id 0 (only forced to be input of &gt;= 1 Workers) and max_queue_id (forced to be output of &gt;=1 Workers). This prevent users from accidentally forgetting connecting some queue ids.</p>
<p>Recursive queuing is allowed. E.g., a Worker might work from queue 0 to 1, another one from 1 to 2, and a third one from 2 to 1, creating a recursive queue/threading. However, the index 0 is reserved for the first queue, and the maximum index for the last one.</p>
<h2><a class="anchor" id="autotoc_md277"></a>
The Worker&lt;T&gt;  Template Class - The Parent Class of All Workers</h2>
<p>Classes starting by the letter <code>W</code> + upper case letter (e.g., <code>WGui</code>) directly or indirectly inherit from Worker&lt;T&gt;. They can be directly added to the <code>ThreadManager</code> class so they can access and/or modify the data as well as be parallelized automatically.</p>
<p>The easiest way to create your own Worker is to inherit Worker&lt;T&gt;, and implement the work() function such us it just calls a wrapper to your desired functionality (check the source code of some of our basic Workers). Since the Worker classes are templates, they are always compiled. Therefore, including your desired functionality in a different file will let you compile it only once. Otherwise, it would be compiled any time that any code which uses your worker is compiled.</p>
<p>All OpenPose Workers are templates, i.e., they are not only limited to work with the default <a class="el" href="structop_1_1_datum.html">op::Datum</a>. However, if you intend to use some of our Workers, your custom <code>TDatums</code> class (the one substituting <a class="el" href="structop_1_1_datum.html">op::Datum</a>) should implement the same variables and functions that those Workers use. The easiest solution is to inherit from <code><a class="el" href="structop_1_1_datum.html">op::Datum</a></code> and extend its functionality.</p>
<h2><a class="anchor" id="autotoc_md278"></a>
Creating New Workers</h2>
<p>Users can directly implement their own <code>W</code> from Worker&lt;T&gt; or any other sub-inherited Worker[...]&lt;T&gt; class and add them to <code>ThreadManager</code>. For that, they just need to: inherit those classes from...</p>
<ol type="1">
<li>Inherit from <code>Worker&lt;T&gt;</code> and implement the functionality <code>work(T&amp; tDatum)</code>, i.e., it will use and modify tDatum.</li>
<li>Inherit from <code>WorkerProducer&lt;T&gt;</code> and implement the functionality <code>T work()</code>, i.e., it will create and return tDatum.</li>
<li>Inherit from <code>WorkerConsumer&lt;T&gt;</code> and implement the functionality <code>work(const T&amp; tDatum)</code>, i.e., it will use but will not modify tDatum.</li>
</ol>
<p>We suggest users to also start their inherited <code>Worker&lt;T&gt;</code> classes with the <code>W</code> letter for code clarity, required if they want to send us a pull request.</p>
<h2><a class="anchor" id="autotoc_md279"></a>
All Workers Wrap a Non-Worker Class</h2>
<p>All Workers wrap and call a non-Worker non-template equivalent which actually performs their functionality. E.g., <code>WPoseExtractor&lt;T&gt;</code> and <code>PoseExtractor</code>. In this way, threading and functionality are completely decoupled. This gives us the best of templates and normal classes:</p>
<ol type="1">
<li>Templates allow us to use different classes, e.g., the user could use his own specific equivalent to <code><a class="el" href="structop_1_1_datum.html">op::Datum</a></code>. However, they must be compiled any time that any function that uses them changes.</li>
<li>Classes can be compiled only once, and later the algorithm just use them. However, they can only be used with specific arguments.</li>
</ol>
<p>By separating functionality and their <code>Worker&lt;T&gt;</code> wrappers, we get the good of both points, eliminating the cons. In this way, the user is able to:</p>
<ol type="1">
<li>Change <code>std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;<a class="el" href="structop_1_1_datum.html">op::Datum</a>&gt;&gt;&gt;</code> for a custom class, implementing his own <code>Worker</code> templates, but using the already implemented functionality to create new custom <code>Worker</code> templates.</li>
<li>Create a <code>Worker</code> which wraps several non-<code>Worker</code>s classes.</li>
</ol>
<h1><a class="anchor" id="autotoc_md280"></a>
Multi-Person Key-Point Detection module - &lt;tt&gt;pose&lt;/tt&gt;</h1>
<p>The human body pose detection is wrapped into the <code>WPoseExtractor&lt;T&gt;</code> worker and its equivalent non-template PoseExtractor. In addition, it can be rendered and/or blended into the original frame with <code>(W)PoseRenderer</code> class.</p>
<h2><a class="anchor" id="autotoc_md281"></a>
PoseExtractor Class</h2>
<p>Currently, only <code>PoseExtractorCaffe</code> is implemented, which uses the Caffe framework. We might add other famous frameworks later (e.g., Torch or TensorFlow). If you compile our library with any other framework, please email us or make a pull request! We are really interested in adding any other Deep Net framework, and the code is mostly prepared for it. Just create the equivalent <code>PoseExtractorDesiredFramework</code> and make the pull request!</p>
<h3><a class="anchor" id="autotoc_md282"></a>
Constructor</h3>
<p>In order to be initialized, <code>PoseExtractorCaffe</code> has the following constructor and parameters: <code>PoseExtractorCaffe(const Point&lt;int&gt;&amp; netInputSize, const Point&lt;int&gt;&amp; netOutputSize, const Point&lt;int&gt;&amp; outputSize, const int scaleNumber, const double scaleGap, const PoseModel poseModel, const std::string&amp; modelsFolder, const int gpuId)</code>.</p>
<ol type="1">
<li><code>netInputSize</code> is the resolution of the first layer of the deep net. I.e., the frames given to this class must have that size.</li>
<li><code>netOutputSize</code> is the resolution of the last layer of the deep net. I.e., the resulting heatmaps will have this size. Currently, it must be set to the same size as <code>netInputSize</code>.</li>
<li><code>outputSize</code> is the final desired resolution to be used. The human pose keypoint locations will be scaled to this output size. However, the heat-maps will have the <code>netOutputSize</code> size due to performance.</li>
<li><code>scaleNumber</code> and <code>scaleGap</code> specify the multi-scale parameters. Explained in <a class="el" href="md_doc_advanced_demo_advanced.html">doc/advanced/demo_advanced.md</a>.</li>
<li><code>poseModel</code> specifies the model to load (e.g., COCO or MPI).</li>
<li><code>modelsFolder</code> is the resolution of the last layer of the deep net. I.e., the resulting heat-maps will have this size.</li>
<li><code>gpuId</code> specifies the GPU where the deep net will run. To parallelize the process along the number of available GPUs, just create the class with the same number of parameters but a different GPU id.</li>
</ol>
<h3><a class="anchor" id="autotoc_md283"></a>
Detect Human Pose</h3>
<p>In order to detect the human pose:</p>
<ol type="1">
<li>First run the deep net over the desired target image, by using <code>forwardPass(const Array&lt;float&gt;&amp; inputNetData, const Point&lt;int&gt;&amp; inputDataSize)</code>. <code>inputNetData</code> is the input image scaled to <code>netInputSize</code>, while <code>inputDataSize</code> indicates the original frame resolution before being rescaled to <code>netInputSize</code> (this is required given that we resize the images keeping the original aspect ratio).</li>
<li>After, you can choose either to get:<ol type="a">
<li>The people pose as a op::Array&lt;float&gt;: <code>Array&lt;float&gt; getPose()</code>.</li>
<li>The scale used (keeping the aspect ratio) to rescale from <code>netOutputSize</code> to <code>outputSize</code>: <code>double getScaleNetToOutput()</code>.</li>
<li>The people pose as a constant GPU float pointer (not implemented yet): <code>const float* getPoseGpuConstPtr()</code>.</li>
<li>The heatmap data as a constant CPU or GPU float pointer: <code>const float* getHeatMapCpuConstPtr()</code> and <code>const float* getHeatMapGpuConstPtr()</code>.</li>
</ol>
</li>
</ol>
<p>Due to performance reasons, we only copy the people pose data given by <code>getPose()</code>. However, we do not copy the heatmap and GPU pose values and just give you a raw pointer to them. Hence, you need to manually copy the data if you pretend to use it later, since we reuse that memory on each <code>forwardPass</code>.</p>
<h2><a class="anchor" id="autotoc_md284"></a>
PoseRenderer Class</h2>
<p>After estimating the pose, you usually desired to visualize it. <code>PoseRenderer</code> does this work for you.</p>
<h3><a class="anchor" id="autotoc_md285"></a>
Constructor</h3>
<p>In order to be initialized, <code>PoseRenderer</code> has the following constructor and parameters: <code>PoseRenderer(const Point&lt;int&gt;&amp; netOutputSize, const Point&lt;int&gt;&amp; outputSize, const PoseModel poseModel, const std::shared_ptr&lt;PoseExtractor&gt;&amp; poseExtractor, const float alphaKeypoint, const float alphaHeatMap)</code>.</p>
<ol type="1">
<li><code>netOutputSize</code>, <code>outputSize</code> and <code>poseModel</code> are the same as the ones used for <code>PoseExtractorCaffe</code>.</li>
<li><code>poseExtractor</code> is the pose extractor used previously. It is only used for heatmap and PAFs rendering, since the GPU data is not copied to <code><a class="el" href="structop_1_1_datum.html">op::Datum</a></code> for performance purposes. If any of the heatmaps are gonna be rendered, <code>PoseRenderer</code> must be placed in the same thread as <code>PoseExtractor</code>. Otherwise, it will throw a runtime exception.</li>
<li><code>alphaKeypoint</code> and <code>alphaHeatMap</code> controls the blending coefficient between original frame and rendered pose or heatmap/PAF respectively. A value <code>alphaKeypoint = 1</code> will render the pose with no transparency at all, while <code>alphaKeypoint = 0</code> will not be visible. In addition, <code>alphaHeatMap = 1</code> would only show the heatmap, while <code>alphaHeatMap = 0</code> would only show the original frame.</li>
</ol>
<h3><a class="anchor" id="autotoc_md286"></a>
Render Human Pose</h3>
<p>In order to render the detected human pose, run <code>std::pair&lt;int, std::string&gt; renderPose(Array&lt;float&gt;&amp; outputData, const Array&lt;float&gt;&amp; pose, const double scaleNetToOutput)</code>.</p>
<ol type="1">
<li><code>outputData</code> is the <a class="el" href="classop_1_1_array.html">Array&lt;float&gt;</a> where the original image resized to <code>outputSize</code> is located.</li>
<li><code>pose</code> is given by <code>PoseExtractor::getPose()</code>.</li>
<li><code>scaleNetToOutput</code> is given by <code>PoseExtractor::getScaleNetToOutput()</code>.</li>
<li>The resulting std::pair has the element rendered id, and its name. E.g., &lt;0, "Nose"&gt; or &lt;19, "Part Affinity Fields"&gt;. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
