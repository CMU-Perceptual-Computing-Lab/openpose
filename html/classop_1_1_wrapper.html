<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>OpenPose: op::Wrapper&lt; TDatums, TWorker, TQueue &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenPose
   &#160;<span id="projectnumber">1.0.0rc2</span>
   </div>
   <div id="projectbrief">OpenPose: A Real-Time Multi-Person Key-Point Detection And Multi-Threading C++ Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classop_1_1_wrapper.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classop_1_1_wrapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">op::Wrapper&lt; TDatums, TWorker, TQueue &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adec2ef07f9796142254cd6dd9a2bf318"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#adec2ef07f9796142254cd6dd9a2bf318">Wrapper</a> (const <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36">ThreadManagerMode</a> threadManagerMode=<a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a>)</td></tr>
<tr class="separator:adec2ef07f9796142254cd6dd9a2bf318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8919b80a6f82330da63da9ffd9ca89be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a8919b80a6f82330da63da9ffd9ca89be">~Wrapper</a> ()</td></tr>
<tr class="separator:a8919b80a6f82330da63da9ffd9ca89be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d02645583cd58d11923df3aa064dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#ad0d02645583cd58d11923df3aa064dc7">disableMultiThreading</a> ()</td></tr>
<tr class="separator:ad0d02645583cd58d11923df3aa064dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f1287f8e4f998504e2ce571ef36f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a74f1287f8e4f998504e2ce571ef36f58">setWorkerInput</a> (const TWorker &amp;worker, const bool workerOnNewThread=true)</td></tr>
<tr class="separator:a74f1287f8e4f998504e2ce571ef36f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2cf45c8b571b99ee92114ba8462589"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a6f2cf45c8b571b99ee92114ba8462589">setWorkerPostProcessing</a> (const TWorker &amp;worker, const bool workerOnNewThread=true)</td></tr>
<tr class="separator:a6f2cf45c8b571b99ee92114ba8462589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9f8993c9a27a012671d671998aa15d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a3e9f8993c9a27a012671d671998aa15d">setWorkerOutput</a> (const TWorker &amp;worker, const bool workerOnNewThread=true)</td></tr>
<tr class="separator:a3e9f8993c9a27a012671d671998aa15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3885bb1b984cad4745fa6e9e0715ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a5a3885bb1b984cad4745fa6e9e0715ad">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;wrapperStructPose, const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;wrapperStructInput, const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;wrapperStructOutput=<a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>{})</td></tr>
<tr class="separator:a5a3885bb1b984cad4745fa6e9e0715ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1deb4a8fc1d942dc1f9b3eb16f74b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#ac1deb4a8fc1d942dc1f9b3eb16f74b8b">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;wrapperStructPose, const <a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a> &amp;wrapperStructHand, const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;wrapperStructInput, const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;wrapperStructOutput=<a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>{})</td></tr>
<tr class="separator:ac1deb4a8fc1d942dc1f9b3eb16f74b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea063b69ea6d68bd7f5292d945667fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#aea063b69ea6d68bd7f5292d945667fb7">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;wrapperStructPose, const <a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a> &amp;wrapperStructFace, const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;wrapperStructInput, const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;wrapperStructOutput=<a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>{})</td></tr>
<tr class="separator:aea063b69ea6d68bd7f5292d945667fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a58d4866cef24edced2979205c87cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a90a58d4866cef24edced2979205c87cc">configure</a> (const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;wrapperStructPose=<a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a>{}, const <a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a> &amp;wrapperStructFace=<a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a>{}, const <a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a> &amp;wrapperStructHand=<a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a>{}, const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;wrapperStructInput=<a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a>{}, const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;wrapperStructOutput=<a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>{})</td></tr>
<tr class="separator:a90a58d4866cef24edced2979205c87cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae0f91a6882f04464d8897a7c81d174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a8ae0f91a6882f04464d8897a7c81d174">exec</a> ()</td></tr>
<tr class="separator:a8ae0f91a6882f04464d8897a7c81d174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338b70f93bfb0ad11b7df6b8db407749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a338b70f93bfb0ad11b7df6b8db407749">start</a> ()</td></tr>
<tr class="separator:a338b70f93bfb0ad11b7df6b8db407749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71f75a631e341dde1c07abcd3a4773f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#ab71f75a631e341dde1c07abcd3a4773f">stop</a> ()</td></tr>
<tr class="separator:ab71f75a631e341dde1c07abcd3a4773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ab9e8a63f8fb822550365fc0417d01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a51ab9e8a63f8fb822550365fc0417d01">isRunning</a> () const </td></tr>
<tr class="separator:a51ab9e8a63f8fb822550365fc0417d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081797a2abda2f91d80876ca6fbb4dbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a081797a2abda2f91d80876ca6fbb4dbc">tryEmplace</a> (std::shared_ptr&lt; TDatums &gt; &amp;tDatums)</td></tr>
<tr class="separator:a081797a2abda2f91d80876ca6fbb4dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23c57fa6b88a0c0bd2348e69a3ad5d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#ab23c57fa6b88a0c0bd2348e69a3ad5d3">waitAndEmplace</a> (std::shared_ptr&lt; TDatums &gt; &amp;tDatums)</td></tr>
<tr class="separator:ab23c57fa6b88a0c0bd2348e69a3ad5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3316c0f86d9d7ca6e246a50d4558e75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#af3316c0f86d9d7ca6e246a50d4558e75">tryPush</a> (const std::shared_ptr&lt; TDatums &gt; &amp;tDatums)</td></tr>
<tr class="separator:af3316c0f86d9d7ca6e246a50d4558e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7c1cff00cd254216b92a0698bf2b6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#acb7c1cff00cd254216b92a0698bf2b6f">waitAndPush</a> (const std::shared_ptr&lt; TDatums &gt; &amp;tDatums)</td></tr>
<tr class="separator:acb7c1cff00cd254216b92a0698bf2b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe5cbb9729cee18531bcbc5e1b2a66e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#aafe5cbb9729cee18531bcbc5e1b2a66e">tryPop</a> (std::shared_ptr&lt; TDatums &gt; &amp;tDatums)</td></tr>
<tr class="separator:aafe5cbb9729cee18531bcbc5e1b2a66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb0c88ab1eab9bc50e224d208cfb310"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_wrapper.html#a1eb0c88ab1eab9bc50e224d208cfb310">waitAndPop</a> (std::shared_ptr&lt; TDatums &gt; &amp;tDatums)</td></tr>
<tr class="separator:a1eb0c88ab1eab9bc50e224d208cfb310"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TDatums, typename TWorker = std::shared_ptr&lt;Worker&lt;std::shared_ptr&lt;TDatums&gt;&gt;&gt;, typename TQueue = Queue&lt;std::shared_ptr&lt;TDatums&gt;&gt;&gt;<br/>
class op::Wrapper&lt; TDatums, TWorker, TQueue &gt;</h3>

<p><a class="el" href="classop_1_1_wrapper.html">Wrapper</a>: OpenPose all-in-one wrapper template class. <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> allows the user to set up the input (video, webcam, custom input, etc.), pose, face and/or hands estimation and rendering, and output (integrated small GUI, custom output, etc.).</p>
<p>This function can be used in 2 ways:</p>
<ul>
<li>Synchronous mode: call the full constructor with your desired input and output workers.</li>
<li>Asynchronous mode: call the empty constructor <a class="el" href="classop_1_1_wrapper.html#adec2ef07f9796142254cd6dd9a2bf318">Wrapper()</a> + use the emplace and pop functions to push the original frames and retrieve the processed ones.</li>
<li>Mix of them:<ul>
<li>Synchronous input + asynchronous output: call the constructor <a class="el" href="classop_1_1_wrapper.html">Wrapper</a>(<a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a>, workersInput, {}, true)</li>
<li>Asynchronous input + synchronous output: call the constructor Wrapper(ThreadManagerMode::Synchronous, nullptr, workersOutput, irrelevantBoolean, true) </li>
</ul>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adec2ef07f9796142254cd6dd9a2bf318"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::<a class="el" href="classop_1_1_wrapper.html">Wrapper</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36">ThreadManagerMode</a>&#160;</td>
          <td class="paramname"><em>threadManagerMode</em> = <code><a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadManagerMode</td><td><a class="el" href="classop_1_1_thread.html">Thread</a> syncronization mode. If set to <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a>, everything will run inside the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a>. If <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a2fe4167817733fec8e6ba1afddf78f1b">ThreadManagerMode::Synchronous</a>(In/Out), then input (frames producer) and/or output (GUI, writing results, etc.) will be controlled outside the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> class by the user. See ThreadManagerMode for a detailed explanation of when to use each one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8919b80a6f82330da63da9ffd9ca89be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::~<a class="el" href="classop_1_1_wrapper.html">Wrapper</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. It automatically frees resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5a3885bb1b984cad4745fa6e9e0715ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructOutput</em> = <code><a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1deb4a8fc1d942dc1f9b3eb16f74b8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructHand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructOutput</em> = <code><a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aea063b69ea6d68bd7f5292d945667fb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructOutput</em> = <code><a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a90a58d4866cef24edced2979205c87cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructPose</em> = <code><a class="el" href="structop_1_1_wrapper_struct_pose.html">WrapperStructPose</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructFace</em> = <code><a class="el" href="structop_1_1_wrapper_struct_face.html">WrapperStructFace</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructHand</em> = <code><a class="el" href="structop_1_1_wrapper_struct_hand.html">WrapperStructHand</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructInput</em> = <code><a class="el" href="structop_1_1_wrapper_struct_input.html">WrapperStructInput</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapperStructOutput</em> = <code><a class="el" href="structop_1_1_wrapper_struct_output.html">WrapperStructOutput</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0d02645583cd58d11923df3aa064dc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::disableMultiThreading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable multi-threading. Useful for debugging and logging, all the Workers will run in the same thread. Note that workerOnNewThread (argument for setWorkerInput, setWorkerPostProcessing and setWorkerOutput) will not make any effect. </p>

</div>
</div>
<a class="anchor" id="a8ae0f91a6882f04464d8897a7c81d174"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::exec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to start multi-threading. Similar to <a class="el" href="classop_1_1_wrapper.html#a338b70f93bfb0ad11b7df6b8db407749">start()</a>, but <a class="el" href="classop_1_1_wrapper.html#a8ae0f91a6882f04464d8897a7c81d174">exec()</a> blocks the thread that calls the function (it saves 1 thread). Use <a class="el" href="classop_1_1_wrapper.html#a8ae0f91a6882f04464d8897a7c81d174">exec()</a> instead of <a class="el" href="classop_1_1_wrapper.html#a338b70f93bfb0ad11b7df6b8db407749">start()</a> if the calling thread will otherwise be waiting for the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> to end. </p>

</div>
</div>
<a class="anchor" id="a51ab9e8a63f8fb822550365fc0417d01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> is running. It will return true after <a class="el" href="classop_1_1_wrapper.html#a8ae0f91a6882f04464d8897a7c81d174">exec()</a> or <a class="el" href="classop_1_1_wrapper.html#a338b70f93bfb0ad11b7df6b8db407749">start()</a> and before <a class="el" href="classop_1_1_wrapper.html#ab71f75a631e341dde1c07abcd3a4773f">stop()</a>, and false otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> is running. </dd></dl>

</div>
</div>
<a class="anchor" id="a74f1287f8e4f998504e2ce571ef36f58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::setWorkerInput </td>
          <td>(</td>
          <td class="paramtype">const TWorker &amp;&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>workerOnNewThread</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an user-defined extra <a class="el" href="classop_1_1_worker.html">Worker</a> as frames generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>TWorker to be added. </td></tr>
    <tr><td class="paramname">workerOnNewThread</td><td>Whether to add this TWorker on a new thread (if it is computationally demanding) or simply reuse existing threads (for light functions). Set to true if the performance time is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e9f8993c9a27a012671d671998aa15d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::setWorkerOutput </td>
          <td>(</td>
          <td class="paramtype">const TWorker &amp;&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>workerOnNewThread</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an user-defined extra <a class="el" href="classop_1_1_worker.html">Worker</a> as frames consumer (custom display and/or saving). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>TWorker to be added. </td></tr>
    <tr><td class="paramname">workerOnNewThread</td><td>Whether to add this TWorker on a new thread (if it is computationally demanding) or simply reuse existing threads (for light functions). Set to true if the performance time is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f2cf45c8b571b99ee92114ba8462589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::setWorkerPostProcessing </td>
          <td>(</td>
          <td class="paramtype">const TWorker &amp;&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>workerOnNewThread</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an user-defined extra <a class="el" href="classop_1_1_worker.html">Worker</a> as frames post-processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>TWorker to be added. </td></tr>
    <tr><td class="paramname">workerOnNewThread</td><td>Whether to add this TWorker on a new thread (if it is computationally demanding) or simply reuse existing threads (for light functions). Set to true if the performance time is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a338b70f93bfb0ad11b7df6b8db407749"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to start multi-threading. Similar to <a class="el" href="classop_1_1_wrapper.html#a8ae0f91a6882f04464d8897a7c81d174">exec()</a>, but <a class="el" href="classop_1_1_wrapper.html#a338b70f93bfb0ad11b7df6b8db407749">start()</a> does not block the thread that calls the function. It just opens new threads, so it lets the user perform other tasks meanwhile on the calling thread. VERY IMPORTANT NOTE: if the GUI is selected and OpenCV is compiled with Qt support, this option will not work. Qt needs the main thread to plot visual results, so the final GUI (which uses OpenCV) would return an exception similar to: <code>QMetaMethod::invoke: Unable to invoke methods with return values in queued connections</code>. Use <a class="el" href="classop_1_1_wrapper.html#a8ae0f91a6882f04464d8897a7c81d174">exec()</a> in that case. </p>

</div>
</div>
<a class="anchor" id="ab71f75a631e341dde1c07abcd3a4773f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to stop multi-threading. It can be called internally or externally. </p>

</div>
</div>
<a class="anchor" id="a081797a2abda2f91d80876ca6fbb4dbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::tryEmplace </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TDatums &gt; &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emplace (move) an element on the first (input) queue. Only valid if <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a288aae25bc408055f50c21c991903a44">ThreadManagerMode::Asynchronous</a> or <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a435b3ab344c03bfc0e4530a2e75f5e44">ThreadManagerMode::AsynchronousIn</a>. If the input queue is full or the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> was stopped, it will return false and not emplace it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>std::shared_ptr&lt;TDatums&gt; element to be emplaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be emplaced. </dd></dl>

</div>
</div>
<a class="anchor" id="aafe5cbb9729cee18531bcbc5e1b2a66e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::tryPop </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TDatums &gt; &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop (retrieve) an element from the last (output) queue. Only valid if <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36a288aae25bc408055f50c21c991903a44">ThreadManagerMode::Asynchronous</a> or <a class="el" href="namespaceop.html#a3593e2d53bec533f0048ef3973eebd36ac68f8680ccf3a65dfcfc63356112c9f9">ThreadManagerMode::AsynchronousOut</a>. If the output queue is empty or the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> was stopped, it will return false and not retrieve it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>std::shared_ptr&lt;TDatums&gt; element where the retrieved element will be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="af3316c0f86d9d7ca6e246a50d4558e75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::tryPush </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; TDatums &gt; &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push (copy) an element on the first (input) queue. Same as tryEmplace, but it copies the data instead of moving it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>std::shared_ptr&lt;TDatums&gt; element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be pushed. </dd></dl>

</div>
</div>
<a class="anchor" id="ab23c57fa6b88a0c0bd2348e69a3ad5d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::waitAndEmplace </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TDatums &gt; &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emplace (move) an element on the first (input) queue. Similar to tryEmplace. However, if the input queue is full, it will wait until it can emplace it. If the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> class is stopped before adding the element, it will return false and not emplace it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>std::shared_ptr&lt;TDatums&gt; element to be emplaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be emplaced. </dd></dl>

</div>
</div>
<a class="anchor" id="a1eb0c88ab1eab9bc50e224d208cfb310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::waitAndPop </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TDatums &gt; &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop (retrieve) an element from the last (output) queue. Similar to tryPop. However, if the output queue is empty, it will wait until it can pop an element. If the <a class="el" href="classop_1_1_wrapper.html">Wrapper</a> class is stopped before popping the element, it will return false and not retrieve it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>std::shared_ptr&lt;TDatums&gt; element where the retrieved element will be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="acb7c1cff00cd254216b92a0698bf2b6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDatums , typename TWorker , typename TQueue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_wrapper.html">op::Wrapper</a>&lt; TDatums, TWorker, TQueue &gt;::waitAndPush </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; TDatums &gt; &amp;&#160;</td>
          <td class="paramname"><em>tDatums</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push (copy) an element on the first (input) queue. Same as waitAndEmplace, but it copies the data instead of moving it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tDatums</td><td>std::shared_ptr&lt;TDatums&gt; element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean specifying whether the tDatums could be pushed. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/CMU-Perceptual-Computing-Lab/openpose/include/openpose/wrapper/<a class="el" href="wrapper_8hpp_source.html">wrapper.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceop.html">op</a></li><li class="navelem"><a class="el" href="classop_1_1_wrapper.html">Wrapper</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
