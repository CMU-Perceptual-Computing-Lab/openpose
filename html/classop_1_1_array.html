<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>OpenPose: op::Array&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenPose
   &#160;<span id="projectnumber">1.0.0rc2</span>
   </div>
   <div id="projectbrief">OpenPose: A Real-Time Multi-Person Key-Point Detection And Multi-Threading C++ Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classop_1_1_array.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classop_1_1_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">op::Array&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a793b9851c7490bc98d4dd52020c0cd3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a793b9851c7490bc98d4dd52020c0cd3c">Array</a> (const int size)</td></tr>
<tr class="separator:a793b9851c7490bc98d4dd52020c0cd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c1ba1f7017b5aa8e0451079dd3a6d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a48c1ba1f7017b5aa8e0451079dd3a6d3">Array</a> (const std::vector&lt; int &gt; &amp;sizes={})</td></tr>
<tr class="separator:a48c1ba1f7017b5aa8e0451079dd3a6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac833fdcb245fcc3135ce65227bb9e4b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ac833fdcb245fcc3135ce65227bb9e4b2">Array</a> (const int size, const T value)</td></tr>
<tr class="separator:ac833fdcb245fcc3135ce65227bb9e4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ede0df7e535d2d3ac40d098541c27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a959ede0df7e535d2d3ac40d098541c27">Array</a> (const std::vector&lt; int &gt; &amp;sizes, const T value)</td></tr>
<tr class="separator:a959ede0df7e535d2d3ac40d098541c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a68cca98a3ebaf565f1e546eebd9f01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a5a68cca98a3ebaf565f1e546eebd9f01">Array</a> (const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>
<tr class="separator:a5a68cca98a3ebaf565f1e546eebd9f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8e006e0eea472485f37971330ecbab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a9c8e006e0eea472485f37971330ecbab">operator=</a> (const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>
<tr class="separator:a9c8e006e0eea472485f37971330ecbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7d854d63815e10e158fe889d17a88e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a7a7d854d63815e10e158fe889d17a88e">Array</a> (<a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&amp;array)</td></tr>
<tr class="separator:a7a7d854d63815e10e158fe889d17a88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae388368128afac05369172198911e05d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ae388368128afac05369172198911e05d">operator=</a> (<a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&amp;array)</td></tr>
<tr class="separator:ae388368128afac05369172198911e05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42f4570122d1b8259c211f52335909b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#af42f4570122d1b8259c211f52335909b">clone</a> () const </td></tr>
<tr class="separator:af42f4570122d1b8259c211f52335909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e538b09e98bf0900163031602ed2ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a12e538b09e98bf0900163031602ed2ed">reset</a> (const int size)</td></tr>
<tr class="separator:a12e538b09e98bf0900163031602ed2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad0232daa69783cf2c8f7a0ff5b3b0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a0ad0232daa69783cf2c8f7a0ff5b3b0c">reset</a> (const std::vector&lt; int &gt; &amp;sizes={})</td></tr>
<tr class="separator:a0ad0232daa69783cf2c8f7a0ff5b3b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7183eb2f4e78a6941da3a2079b9ed32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ac7183eb2f4e78a6941da3a2079b9ed32">reset</a> (const int size, const T value)</td></tr>
<tr class="separator:ac7183eb2f4e78a6941da3a2079b9ed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2eeccd967cdf0900449649cb6f5afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#add2eeccd967cdf0900449649cb6f5afb">reset</a> (const std::vector&lt; int &gt; &amp;sizes, const T value)</td></tr>
<tr class="separator:add2eeccd967cdf0900449649cb6f5afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf43d039478797722cf9401ceb951e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a6bf43d039478797722cf9401ceb951e9">setFrom</a> (const cv::Mat &amp;cvMat)</td></tr>
<tr class="separator:a6bf43d039478797722cf9401ceb951e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f09d11de753a741334ee8094296acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a28f09d11de753a741334ee8094296acb">setTo</a> (const T value)</td></tr>
<tr class="separator:a28f09d11de753a741334ee8094296acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51b6ac12ed115f1056effefd6fa878b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ad51b6ac12ed115f1056effefd6fa878b">empty</a> () const </td></tr>
<tr class="separator:ad51b6ac12ed115f1056effefd6fa878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2330657a79a444d1ab44370423be006e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a2330657a79a444d1ab44370423be006e">getSize</a> () const </td></tr>
<tr class="separator:a2330657a79a444d1ab44370423be006e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146d6e773e14dd7aaa29a73f878358e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a146d6e773e14dd7aaa29a73f878358e1">getSize</a> (const int index) const </td></tr>
<tr class="separator:a146d6e773e14dd7aaa29a73f878358e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb008e878709bb5a51e26be55a5452d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#adeb008e878709bb5a51e26be55a5452d">getNumberDimensions</a> () const </td></tr>
<tr class="separator:adeb008e878709bb5a51e26be55a5452d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee5e6149bc917586b3fd56323d20a87"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#afee5e6149bc917586b3fd56323d20a87">getVolume</a> () const </td></tr>
<tr class="separator:afee5e6149bc917586b3fd56323d20a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d04645dd2b2f21492b2ad7a5b87828"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a04d04645dd2b2f21492b2ad7a5b87828">getVolume</a> (const int indexA, const int indexB) const </td></tr>
<tr class="separator:a04d04645dd2b2f21492b2ad7a5b87828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4715967fd2b028a97fd30257e697275"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#af4715967fd2b028a97fd30257e697275">getPtr</a> ()</td></tr>
<tr class="separator:af4715967fd2b028a97fd30257e697275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a44d11cf476f705ce4a5223cfb4f81"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a17a44d11cf476f705ce4a5223cfb4f81">getConstPtr</a> () const </td></tr>
<tr class="separator:a17a44d11cf476f705ce4a5223cfb4f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70165463db3e2fb3f15ad14001eb592"><td class="memItemLeft" align="right" valign="top">const cv::Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ab70165463db3e2fb3f15ad14001eb592">getConstCvMat</a> () const </td></tr>
<tr class="separator:ab70165463db3e2fb3f15ad14001eb592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac817621e848601cf7d6571e75d8f6865"><td class="memItemLeft" align="right" valign="top">cv::Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ac817621e848601cf7d6571e75d8f6865">getCvMat</a> ()</td></tr>
<tr class="separator:ac817621e848601cf7d6571e75d8f6865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40dc59e800d3c4cce623d560c0e0fad"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#aa40dc59e800d3c4cce623d560c0e0fad">operator[]</a> (const int index)</td></tr>
<tr class="separator:aa40dc59e800d3c4cce623d560c0e0fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccfa42607d5deb5039ff260eb980abc"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#aeccfa42607d5deb5039ff260eb980abc">operator[]</a> (const int index) const </td></tr>
<tr class="separator:aeccfa42607d5deb5039ff260eb980abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada0f1bd6e9eb73b4f977e62da536f58"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#aada0f1bd6e9eb73b4f977e62da536f58">operator[]</a> (const std::vector&lt; int &gt; &amp;indexes)</td></tr>
<tr class="separator:aada0f1bd6e9eb73b4f977e62da536f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6c6f7ddeed3d1edbc907441888a8cf"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a3f6c6f7ddeed3d1edbc907441888a8cf">operator[]</a> (const std::vector&lt; int &gt; &amp;indexes) const </td></tr>
<tr class="separator:a3f6c6f7ddeed3d1edbc907441888a8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0afd5f447efbfc29efbeac62716eff"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at</a> (const int index)</td></tr>
<tr class="separator:a6e0afd5f447efbfc29efbeac62716eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e83e3379fd43460db68c2adb61f981"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a95e83e3379fd43460db68c2adb61f981">at</a> (const int index) const </td></tr>
<tr class="separator:a95e83e3379fd43460db68c2adb61f981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eebb6c34642cdf19ac74c7ed38d128b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a8eebb6c34642cdf19ac74c7ed38d128b">at</a> (const std::vector&lt; int &gt; &amp;indexes)</td></tr>
<tr class="separator:a8eebb6c34642cdf19ac74c7ed38d128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb014203b418de3996b90597df53b6e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#a5cb014203b418de3996b90597df53b6e">at</a> (const std::vector&lt; int &gt; &amp;indexes) const </td></tr>
<tr class="separator:a5cb014203b418de3996b90597df53b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ec6553128d77b0c26b848c0a0f81ca"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classop_1_1_array.html#ae3ec6553128d77b0c26b848c0a0f81ca">toString</a> () const </td></tr>
<tr class="separator:ae3ec6553128d77b0c26b848c0a0f81ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class op::Array&lt; T &gt;</h3>

<p>Array&lt;T&gt;: The OpenPose Basic Raw Data Container This template class implements a multidimensional data array. It is our basic data container, analogous to cv::Mat in OpenCV, Tensor in Torch/TensorFlow or Blob in Caffe. It wraps a cv::Mat and a std::shared_ptr, both of them pointing to the same raw data. I.e. they both share the same memory, so we can read and modify this data in both formats with no performance impact. Hence, it keeps high performance while adding high-level functions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a793b9851c7490bc98d4dd52020c0cd3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor + <a class="el" href="classop_1_1_array.html#a12e538b09e98bf0900163031602ed2ed">reset(const int size)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g. size = 5 is internally similar to: new T[5]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48c1ba1f7017b5aa8e0451079dd3a6d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor + reset(const std::vector&lt;int&gt;&amp; size = {}). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g. size = {3, 5, 2} is internally similar to: new T[3*5*2]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac833fdcb245fcc3135ce65227bb9e4b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor + <a class="el" href="classop_1_1_array.html#ac7183eb2f4e78a6941da3a2079b9ed32">reset(const int size, const T value)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g. size = 5 is internally similar to: new T[5]. </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a959ede0df7e535d2d3ac40d098541c27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html">Array</a> constructor. Equivalent to default constructor + <a class="el" href="classop_1_1_array.html#add2eeccd967cdf0900449649cb6f5afb">reset(const std::vector&lt;int&gt;&amp; size, const T value)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g. size = {3, 5, 2} is internally similar to: new T[3*5*2]. </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a68cca98a3ebaf565f1e546eebd9f01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. It performs <code>fast copy</code>: For performance purpose, copying a Array&lt;T&gt; or <a class="el" href="structop_1_1_datum.html">Datum</a> or cv::Mat just copies the reference, it still shares the same internal data. Modifying the copied element will modify the original one. Use <a class="el" href="classop_1_1_array.html#af42f4570122d1b8259c211f52335909b">clone()</a> for a slower but real copy, similarly to cv::Mat and Array&lt;T&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><a class="el" href="classop_1_1_array.html">Array</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a7d854d63815e10e158fe889d17a88e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::<a class="el" href="classop_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor. It destroys the original <a class="el" href="classop_1_1_array.html">Array</a> to be moved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><a class="el" href="classop_1_1_array.html">Array</a> to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6e0afd5f447efbfc29efbeac62716eff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at()</a> function Same functionality as <a class="el" href="classop_1_1_array.html#aa40dc59e800d3c4cce623d560c0e0fad">operator[](const int index)</a>, but it always check whether the indexes are within the data bounds. Otherwise, it will throw an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A editable reference to the data on the desired index location. </dd></dl>

</div>
</div>
<a class="anchor" id="a95e83e3379fd43460db68c2adb61f981"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at()</a> function Same functionality as <a class="el" href="classop_1_1_array.html#aeccfa42607d5deb5039ff260eb980abc">operator[](const int index) const</a>, but it always check whether the indexes are within the data bounds. Otherwise, it will throw an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-editable reference to the data on the desired index location. </dd></dl>

</div>
</div>
<a class="anchor" id="a8eebb6c34642cdf19ac74c7ed38d128b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at()</a> function Same functionality as <a class="el" href="classop_1_1_array.html#aada0f1bd6e9eb73b4f977e62da536f58">operator[](const std::vector&lt;int&gt;&amp; indexes)</a>, but it always check whether the indexes are within the data bounds. Otherwise, it will throw an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>Vector with the desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A editable reference to the data on the desired index location. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cb014203b418de3996b90597df53b6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classop_1_1_array.html#a6e0afd5f447efbfc29efbeac62716eff">at()</a> function Same functionality as <a class="el" href="classop_1_1_array.html#a3f6c6f7ddeed3d1edbc907441888a8cf">operator[](const std::vector&lt;int&gt;&amp; indexes) const</a>, but it always check whether the indexes are within the data bounds. Otherwise, it will throw an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>Vector with the desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-editable reference to the data on the desired index location. </dd></dl>

</div>
</div>
<a class="anchor" id="af42f4570122d1b8259c211f52335909b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">Array</a>&lt;T&gt; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clone function. Similar to cv::Mat::clone and <a class="el" href="structop_1_1_datum.html#a847f62b3060c5d0d106e60c29df87a0b">Datum::clone</a>. It performs a real but slow copy of the data, i.e., even if the copied element is modified, the original one is not. </p>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classop_1_1_array.html">Array</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad51b6ac12ed115f1056effefd6fa878b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether memory has been allocated. </p>
<dl class="section return"><dt>Returns</dt><dd>True if no memory has been allocated, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab70165463db3e2fb3f15ad14001eb592"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const cv::Mat&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getConstCvMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a cv::Mat wrapper to the data. It forbids the data to be modified. OpenCV only admits unsigned char, signed char, int, float &amp; double. If the T class is not supported by OpenCV, it will throw an error. Note: Array&lt;T&gt; does not return an editable cv::Mat because some OpenCV functions reallocate memory and it would not longer point to the Array&lt;T&gt; instance. If you want to perform some OpenCV operation on the <a class="el" href="classop_1_1_array.html">Array</a> data, you can use: editedCvMat = array.getConstCvMat().<a class="el" href="classop_1_1_array.html#af42f4570122d1b8259c211f52335909b">clone()</a>; // modify data array.setFrom(editedCvMat) </p>
<dl class="section return"><dt>Returns</dt><dd>A const cv::Mat pointing to the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a17a44d11cf476f705ce4a5223cfb4f81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getConstPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classop_1_1_array.html#af4715967fd2b028a97fd30257e697275">getPtr()</a>, but it forbids the data to be edited. </p>
<dl class="section return"><dt>Returns</dt><dd>A raw const pointer to the data. </dd></dl>

</div>
</div>
<a class="anchor" id="ac817621e848601cf7d6571e75d8f6865"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getCvMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogous to getConstCvMat, but in this case it returns a editable cv::Mat. Very important: Only allowed functions which do not provoke data reallocation. E.g. resizing functions will not work and they would provoke an undefined behaviour and/or execution crashes. </p>
<dl class="section return"><dt>Returns</dt><dd>A cv::Mat pointing to the data. </dd></dl>

</div>
</div>
<a class="anchor" id="adeb008e878709bb5a51e26be55a5452d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getNumberDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of dimensions, equivalent to <a class="el" href="classop_1_1_array.html#a2330657a79a444d1ab44370423be006e">getSize()</a>.size(). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dimensions. If no memory is allocated, it returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="af4715967fd2b028a97fd30257e697275"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a raw pointer to the data. Similar to: std::shared_ptr::get(). Note: if you modify the pointer data, you will directly modify it in the Array&lt;T&gt; instance too. If you know you do not want to modify the data, then use <a class="el" href="classop_1_1_array.html#a17a44d11cf476f705ce4a5223cfb4f81">getConstPtr()</a> instead. </p>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer to the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a2330657a79a444d1ab44370423be006e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector with the size of each dimension allocated. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;int&gt; with the size of each dimension. If no memory has been allocated, it will return an empty std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a146d6e773e14dd7aaa29a73f878358e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getSize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector with the size of the desired dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Dimension to check its size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the desired dimension. It will return 0 if the requested dimension is higher than the number of dimensions. </dd></dl>

</div>
</div>
<a class="anchor" id="afee5e6149bc917586b3fd56323d20a87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of elements allocated, equivalent to multiply all the components from <a class="el" href="classop_1_1_array.html#a2330657a79a444d1ab44370423be006e">getSize()</a>. E.g. for a Array&lt;T&gt; of size = {2,5,3}, the volume or total number of elements is: 2x5x3 = 30. </p>
<dl class="section return"><dt>Returns</dt><dd>The total volume of the allocated data. If no memory is allocated, it returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a04d04645dd2b2f21492b2ad7a5b87828"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::getVolume </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indexA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indexB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classop_1_1_array.html#afee5e6149bc917586b3fd56323d20a87">getVolume()</a>, but in this case it just returns the volume between the desired dimensions. E.g. for a Array&lt;T&gt; of size = {2,5,3}, the volume or total number of elements for getVolume(1,2) is: 5x3 = 15. </p>
<dl class="section return"><dt>Returns</dt><dd>The total volume of the allocated data between the desired dimensions. If the index are out of bounds, it throws an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c8e006e0eea472485f37971330ecbab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy assignment. Similar to <a class="el" href="classop_1_1_array.html#a5a68cca98a3ebaf565f1e546eebd9f01">Array&lt;T&gt;(const Array&lt;T&gt;&amp; array)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><a class="el" href="classop_1_1_array.html">Array</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classop_1_1_array.html">Array</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae388368128afac05369172198911e05d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classop_1_1_array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classop_1_1_array.html">Array</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move assignment. Similar to <a class="el" href="classop_1_1_array.html#a7a7d854d63815e10e158fe889d17a88e">Array&lt;T&gt;(Array&lt;T&gt;&amp;&amp; array)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><a class="el" href="classop_1_1_array.html">Array</a> to be moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classop_1_1_array.html">Array</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa40dc59e800d3c4cce623d560c0e0fad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[] operator Similar to the [] operator for raw pointer data. If debug mode is enabled, then it will check that the desired index is in the data range, and it will throw an exception otherwise (similar to the at operator). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A editable reference to the data on the desired index location. </dd></dl>

</div>
</div>
<a class="anchor" id="aeccfa42607d5deb5039ff260eb980abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[] operator Same functionality as <a class="el" href="classop_1_1_array.html#aa40dc59e800d3c4cce623d560c0e0fad">operator[](const int index)</a>, but it forbids modifying the value. Otherwise, const functions would not be able to call the [] operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-editable reference to the data on the desired index location. </dd></dl>

</div>
</div>
<a class="anchor" id="aada0f1bd6e9eb73b4f977e62da536f58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[] operator Same functionality as <a class="el" href="classop_1_1_array.html#aa40dc59e800d3c4cce623d560c0e0fad">operator[](const int index)</a>, but it lets the user introduce the multi-dimensional index. E.g. given a (10 x 10 x 10) array, array[11] is equivalent to array[{1,1,0}] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>Vector with the desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A editable reference to the data on the desired index location. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f6c6f7ddeed3d1edbc907441888a8cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[] operator Same functionality as <a class="el" href="classop_1_1_array.html#aada0f1bd6e9eb73b4f977e62da536f58">operator[](const std::vector&lt;int&gt;&amp; indexes)</a>, but it forbids modifying the value. Otherwise, const functions would not be able to call the [] operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>Vector with the desired memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-editable reference to the data on the desired index location. </dd></dl>

</div>
</div>
<a class="anchor" id="a12e538b09e98bf0900163031602ed2ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. It allocates the required space for the memory (it does not initialize that memory). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g. size = 5 is internally similar to: new T[5]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ad0232daa69783cf2c8f7a0ff5b3b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. Similar to <a class="el" href="classop_1_1_array.html#a12e538b09e98bf0900163031602ed2ed">reset(const int size)</a>, but it allocates a multi-dimensional array of dimensions each of the values of the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g. size = {3, 5, 2} is internally similar to: new T[3*5*2]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7183eb2f4e78a6941da3a2079b9ed32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. Similar to <a class="el" href="classop_1_1_array.html#a12e538b09e98bf0900163031602ed2ed">reset(const int size)</a>, but initializing the data to the value specified by the second argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Integer with the number of T element to be allocated. E.g. size = 5 is internally similar to: new T[5]. </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add2eeccd967cdf0900449649cb6f5afb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. Similar to <a class="el" href="classop_1_1_array.html#a0ad0232daa69783cf2c8f7a0ff5b3b0c">reset(const std::vector&lt;int&gt;&amp; size)</a>, but initializing the data to the value specified by the second argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector with the size of each dimension. E.g. size = {3, 5, 2} is internally similar to: new T[3*5*2]. </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bf43d039478797722cf9401ceb951e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::setFrom </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>cvMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. It internally allocates memory and copies the data of the argument to the <a class="el" href="classop_1_1_array.html">Array</a> allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cvMat</td><td>cv::Mat to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28f09d11de753a741334ee8094296acb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::setTo </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data allocation function. It internally assigns all the allocated memory to the value indicated by the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value for each component of the <a class="el" href="classop_1_1_array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3ec6553128d77b0c26b848c0a0f81ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classop_1_1_array.html">op::Array</a>&lt; T &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns a string with the whole array data. Useful for debugging. The format is: values separated by a space, and a enter for each dimension. E.g.: For the <a class="el" href="classop_1_1_array.html">Array</a>{2, 2, 3}, it will print: <a class="el" href="classop_1_1_array.html#ae3ec6553128d77b0c26b848c0a0f81ca">Array&lt;T&gt;::toString()</a>: x1 x2 x3 x4 x5 x6</p>
<p>x7 x8 x9 x10 x11 x12 </p>
<dl class="section return"><dt>Returns</dt><dd>A string with the array values in the above format. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/CMU-Perceptual-Computing-Lab/openpose/include/openpose/core/<a class="el" href="array_8hpp_source.html">array.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceop.html">op</a></li><li class="navelem"><a class="el" href="classop_1_1_array.html">Array</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
